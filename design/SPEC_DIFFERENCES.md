# Go Specification Divergences in GoScript

This document outlines known areas where the TypeScript code generated by GoScript diverges from the official Go language specification.

## Lexical Elements

### Comments
- **Go:** Line comments (`//`) and general comments (`/* ... */`).
- **GoScript:** Comments are generally preserved and translated to their TypeScript equivalents.
- **Divergence:** No known major divergences in comment handling itself, but the impact of comments on semicolon insertion (Go spec: "Any other comment acts like a newline") needs to be considered in the context of GoScript's semicolon-free output.

### Tokens
- **Go:** Identifiers, keywords, operators/punctuation, literals. Whitespace is ignored except to separate tokens or trigger semicolon insertion.
- **GoScript:** Aims to map these concepts to TypeScript.
- **Divergence:**
    - **Identifiers:**
        - **Go:** Sequence of one or more letters and digits; first character must be a letter. Underscore `_` is considered a letter. Unicode letters and digits are permitted.
        - **TypeScript:** Similar rules; Unicode letters and digits are allowed, `_` is allowed. Identifiers cannot be reserved words.
        - **Divergence/Considerations:**
            - **Exported/Unexported:** Go's convention of using capitalization for export visibility (e.g., `ExportedVar`, `unexportedVar`) needs to be translated. For top-level declarations, GoScript translates this to TypeScript `export` statements. For struct fields, this typically translates to standard TypeScript field declarations, as TypeScript's `public`/`private` are structural. The effective visibility in TypeScript might differ from Go's package-level unexported visibility.
            - **Predeclared Identifiers:** Go has several predeclared identifiers (e.g., `nil`, `iota`, `true`, `false`, built-in types like `int`, `string`, and functions like `make`, `len`, `append`, `println`). GoScript must map these:
                - `nil`: Typically maps to `null` or a custom `gs.nil` for type compatibility.
                - `iota`: Handled during constant declaration translation.
                - `true`, `false`: Map directly to TypeScript `true`, `false`.
                - Built-in types: Mapped to TypeScript equivalents (e.g., `string` to `string`, `int` to `number`) or custom types from the `gs` runtime.
                - Built-in functions (`make`, `len`, `append`, `new`, `cap`, `panic`, `recover`, `complex`, `real`, `imag`, `close`, `delete`, `print`, `println`): Require implementations or mappings in the GoScript runtime (`@goscript/builtin`).
            - **Blank Identifier (`_`):**
                - **Go:** Can be used to ignore values in assignments, for unused imports, or unused variables.
                - **TypeScript:** `_` can be a normal variable name. While often used by convention for unused parameters, it doesn't have the same compiler-enforced "ignore" semantics as in Go for assignments like `_ = someFunc()`.
                - **GoScript:** For assignments like `_ = val`, GoScript should ensure no actual assignment code is generated if the RHS has no side effects, or that the side effects are preserved. For unused imports, Go's compiler checks this; GoScript relies on the Go parser/type-checker for this information.
    - **Keywords:**
        - **Go:** Reserved set (e.g., `func`, `struct`, `chan`, `defer`, `go`, `goto`).
        - **TypeScript:** Has its own set of reserved words (e.g., `class`, `enum`, `public`, `async`, `await`).
        - **Divergence/Considerations:**
            - **Name Clashes:** A valid Go identifier might be a TypeScript keyword (e.g., Go: `var class int`). GoScript must mangle such identifiers (e.g., to `class_` or `_class`) to avoid syntax errors in TypeScript. The `compiler.WriteIdent` function handles some of this.
            - **`goto`:** Go supports `goto` and labels. TypeScript has no `goto`. GoScript currently does not support `goto` (no `WriteStmtGoto`). Full support would require complex and potentially unreadable code transformations (e.g., using loops and state machines).
            - **Concurrency Keywords (`go`, `chan`, `select`):** These are core to Go's concurrency model. TypeScript lacks direct equivalents. GoScript translates `go` routines to asynchronous operations (e.g., `async` functions, Promises). `chan` and `select` require significant runtime support provided by `@goscript/builtin` and complex transformations.
            - **`defer`:** Go's `defer` statement schedules a function call to be run when the surrounding function returns. TypeScript uses `try...finally`. GoScript implements `defer` using a `try...finally` pattern and a list of deferred functions.
            - **`range` (on channels):** Special Go construct. Requires runtime support for channel iteration.
    - **Operators and Punctuation:**
        - **Go:** Defines a specific set of operators and punctuation (e.g., `+`, `*`, `&`, `*` (pointer), `<-`, `&^`).
        - **TypeScript:** Has a largely similar set, but with some key differences.
        - **Divergence/Considerations:**
            - **Bitwise Clear (`&^`):** Go has `x &^ y` (AND NOT). TypeScript does not have a direct equivalent. GoScript must translate this to `x & (~y)`.
            - **Channel Operators (`<-`):** Used for sending and receiving on channels in Go. TypeScript has no native channels. GoScript translates these into calls to its runtime channel implementation.
            - **Pointer Operators (`*` dereference, `&` address-of):** Go has explicit pointer manipulation. TypeScript does not have pointers in the same way. GoScript simulates pointer semantics using varRefing and runtime helper functions. `*expr` (dereference) and `&expr` (address-of) are translated into these runtime calls or operations on wrapped objects.
            - **Short Variable Declaration (`:=`):** Go uses `:=` for declaration and initialization. TypeScript uses `let` or `const`. GoScript's `WriteStmtAssign` handles this translation.
            - **Variadic Functions (`...`):** Go uses `...T` for variadic parameters and `f(slice...)` for arguments. TypeScript uses `...T[]` for rest parameters and spread syntax `...array`. This maps fairly well.
    - **Semicolons:**
        - **Go:** Has specific rules for automatic semicolon insertion. Semicolons are formal terminators in many productions.
        - **GoScript:** Generated TypeScript aims to be semicolon-free, relying on TypeScript's Automatic Semicolon Insertion (ASI).
        - **Potential Divergence:** Differences between Go's semicolon insertion rules and TypeScript's ASI rules could lead to different statement parsing and thus behavior. For example, Go's rule about a line's final token (identifier, literal, `break`, `continue`, `fallthrough`, `return`, `++`, `--`, `)`, `}`, `]`) triggering a semicolon is specific. GoScript must generate TypeScript such that TypeScript's ASI produces the same program structure.

### Literals

#### Integer Literals
- **Go:** Supports decimal (`123`), binary (`0b101`), octal (`0777`, `0o777`), and hexadecimal (`0xFF`) literals.
- **GoScript (`WriteBasicLit`):**
    - Decimal, binary, hex: `exp.Value` is written directly. TypeScript supports these.
    - **Octal:**
        - **Go:** `0o777` (new form) and `0777` (legacy form).
        - **TypeScript:** Only supports `0o777`.
        - **Divergence:** GoScript currently writes `exp.Value` directly for all integer literals. This means legacy Go octal literals (e.g., `0123`) will be interpreted by TypeScript as decimal numbers if they don't contain `8` or `9` (e.g. `0123` becomes `123` decimal in TS, not `83` decimal). If they contain `8` or `9` (e.g. `0789`), they are invalid octal in Go but would be treated as decimal `789` in TS if not for Go's parser catching it. GoScript should explicitly convert legacy Go octal literals to the `0o` prefix form for TypeScript or parse them as base-8 integers.

#### Rune Literals
- **Go:** Represents a single Unicode code point, type `rune` (alias for `int32`). E.g., `'a'`, `'\n'`, `'\u0041'`.
- **GoScript (`WriteBasicLit`):** Translates Go rune literals (e.g., `'a'`) to their numeric Unicode code point in TypeScript (e.g., `97`).
- **Divergence:** This is a change in representation (Go character literal vs. TS number literal), but semantically consistent as Go runes are integer values. Escape sequences are handled by `strconv.UnquoteChar`.

#### Floating-point Literals
- **Go:** E.g., `3.14`, `1e3`, `.5`.
- **GoScript (`WriteBasicLit`):** Writes `exp.Value` directly.
- **Divergence:** Generally compatible. TypeScript supports these forms.

#### Imaginary Literals
- **Go:** E.g., `3i`, `2.5i`. Represents complex number components.
- **GoScript (`WriteBasicLit`):** Writes `exp.Value` directly (e.g., `3i`).
- **Divergence:** Major. TypeScript has no native support for imaginary literals. `3i` in TypeScript would be a compile-time error (if `i` is not defined) or interpreted as `3 * i`. GoScript needs a runtime representation for complex numbers and must translate imaginary literals into operations involving this representation (e.g., `gs.complex(0, 3)`).

#### String Literals
- **Go:**
    - **Interpreted string literals (`""`):** Allow various escape sequences.
        - `\xHH`, `\ooo` (octal) escapes represent individual *bytes*.
        - `\uHHHH`, `\UHHHHHHHH`, and other recognized escapes (e.g., `\n`, `\t`) represent UTF-8 encodings of characters.
    - **Raw string literals (`` ` `` ``):** No escape processing. Content is taken as is, except carriage returns (`\r`) are discarded. Can span multiple lines.
- **GoScript (`WriteBasicLit`):** Writes `exp.Value` (the unquoted, escape-processed string value from the Go AST) directly for strings.
- **Divergence/Considerations:**
    - **Interpreted Strings:**
        - The `exp.Value` from Go's parser already contains the actual string content after Go's escape rules (including byte-level interpretation for `\x` and octal escapes) have been applied. TypeScript strings are sequences of UTF-16 code units. While Go strings can conceptually hold arbitrary bytes, `exp.Value` should generally form a valid sequence that can be represented in TypeScript.
        - **Potential minor issue:** If Go's byte-level escapes (e.g., `\xff`) result in byte sequences that are not valid UTF-8 (and thus not valid Unicode characters), how these are represented in `exp.Value` (as a Go `string`) and subsequently in a TypeScript string needs careful consideration. However, Go strings themselves are typically expected to hold valid UTF-8. The Go spec says "string values are UTF-8 encoded".
    - **Raw Strings:**
        - **Go:** ` `` ` literals do not process any escape sequences. Carriage returns (`\r`) are discarded.
        - **TypeScript:** Template literals ` `` ` *do* process `${expression}` interpolations and standard escape sequences (e.g., `\n`, `\u{...}`).
        - **Potential Divergence:** The direct use of `exp.Value` (which is the content of the Go raw string) inside TypeScript backticks ` `` ` is problematic if the Go raw string contains sequences like `${` or backslashes that have special meaning in TS template literals.
        - **GoScript Recommendation:** GoScript should convert Go raw string literals into regular TypeScript double-quoted string literals (`""`), meticulously escaping any characters that require it in TypeScript strings (e.g., `"` itself, `\`, newlines) to preserve the exact string value obtained from `exp.Value`. The `exp.Value` for a raw string literal from the Go parser will already have `\r` removed.
        - The current `WriteBasicLit` writes `exp.Value` directly. For raw strings, this means `gs.tsw.WriteLiterally(\`raw string content\`)`. This is the problematic behavior.

## Constants

-   **Go Specification:**
    -   Categories: Boolean, rune, integer, floating-point, complex, string. Numeric constants (rune, integer, float, complex) are collectively called numeric.
    -   Representation: Literals, identifiers denoting constants, constant expressions, results of certain built-in functions (`unsafe.Sizeof`, `cap`, `len` on specific args, `real`, `imag`, `complex`).
    -   Truth values: `true`, `false`. `iota` for integer constants.
    -   Precision: Numeric constants represent exact values of arbitrary precision; no overflow in constants themselves. No IEEE 754 special values (NaN, Inf) as constants.
    -   Typed vs. Untyped: Literal constants, `true`, `false`, `iota`, and expressions with only untyped constant operands are untyped.
    -   Explicit Typing: Via constant declaration or conversion.
    -   Implicit Typing: When used in variable declarations, assignments, or as operands. Error if value not representable by target type.
    -   Default Types (for untyped constants): `bool`, `rune`, `int`, `float64`, `complex128`, or `string`.
    -   Implementation Requirements: Min 256 bits for integers; min 256-bit mantissa and 16-bit exponent for floats/complex parts. Error on imprecise int representation or float/complex overflow; round on precision limits.

-   **GoScript & Divergences:**
    -   **Numeric Precision & Representation:**
        -   **Go:** Arbitrary precision for constants.
        -   **TypeScript:** `number` type is IEEE 754 double-precision. `BigInt` for arbitrary-precision integers.
        -   **Divergence:** GoScript must handle Go's arbitrary-precision numeric constants.
            -   For integers, if a constant exceeds TypeScript's `number` safe integer limits, it should be translated to a `BigInt` literal (e.g., `123n`).
            -   For floating-point, TypeScript `number` has limited precision. GoScript will likely use standard TS numbers, leading to potential precision loss for very high-precision Go float constants. The Go spec's 256-bit mantissa requirement for constants is far beyond TS `number`.
            -   The `compiler.WriteBasicLit` writes literal values. For large integers, this might produce numbers that TS interprets as floats if not suffixed with `n`.
    -   **Untyped Constants & Default Types:**
        -   **Go:** Untyped constants adapt to their context or use a default type.
        -   **TypeScript:** Type inference is strong. `const x = 10;` infers `x` as type `10` (literal type), which widens to `number`.
        -   **Divergence:** GoScript needs to ensure that the type inferred by TypeScript, or explicitly annotated, aligns with Go's rules. For example, `i := 0` (Go `int`) should become `let i = 0;` (TS `number`), which is generally compatible for typical integer ranges. `f := 0.0` (Go `float64`) becomes `let f = 0.0;` (TS `number`).
    -   **`iota`:**
        -   **Go:** Special constant generator.
        -   **TypeScript:** No direct equivalent.
        -   **Divergence:** GoScript handles `iota` by calculating its value during the compilation of `const` blocks (see `compiler.WriteValueSpec`). This is a compile-time transformation.
    -   **Complex Constants:**
        -   **Go:** Supported, default type `complex128`.
        -   **TypeScript:** No native complex type.
        -   **Divergence:** GoScript represents complex numbers using a runtime type (e.g., `gs.Complex` from `@goscript/builtin`). Complex constants must be translated into instantiations of this runtime type (e.g., `gs.complex(realPart, imagPart)`). `compiler.WriteValueExpr` would need to handle this for constant expressions.
    -   **Constant Evaluation:** Go evaluates constant expressions at compile time with arbitrary precision. GoScript relies on the Go compiler's frontend to evaluate these and provide the exact values. The challenge is then representing these exact values in TypeScript.

## Variables

-   **Go Specification:**
    -   Definition: A storage location for a value, determined by its type.
    -   Declaration: `var` keyword, function parameters/results reserve storage.
    -   Allocation: `new(T)` or taking address of composite literal allocates at runtime (anonymous variable via pointer).
    -   Structured Variables: Array, slice, struct elements/fields are addressable, act like variables.
    -   Static Type: Type given in declaration, `new` call, or composite literal.
    -   Dynamic Type (for interfaces): Actual non-interface type of the value assigned at runtime. `nil` has no dynamic type.
    -   Value Retrieval: Referring to the variable in an expression.
    -   Zero Value: If not assigned, a variable holds the zero value for its type.

-   **GoScript & Divergences:**
    -   **Zero Value Initialization:**
        -   **Go:** Variables are automatically initialized to their type's zero value.
        -   **TypeScript:** Variables are `undefined` if not explicitly initialized.
        -   **Divergence:** GoScript *must* explicitly initialize all Go variables to their corresponding zero values in the generated TypeScript code. This is handled by `compiler.WriteZeroValueForType` during variable declarations.
    -   **`new(T)`:**
        -   **Go:** Allocates zeroed memory for a `T` and returns `*T`.
        -   **TypeScript:** No direct equivalent.
        -   **Divergence:** GoScript translates `new(T)` into code that creates an instance of the TypeScript type corresponding to `T`, ensuring it's properly zero-initialized, and then returns a "pointer" to it (often a varrefed value or a direct reference if `T` is a class). See `gs.New` in runtime.
    -   **Pointers and Addressability:**
        -   **Go:** Explicit pointers (`*T`) and address-of operator (`&`).
        -   **TypeScript:** No direct pointer arithmetic or C-like pointers. Object references behave somewhat like pointers.
        -   **Divergence:** This is a fundamental difference. GoScript simulates pointers using:
            -   VarRefing: Wrapping primitive types or structs in a container object (e.g., `gs.VarRef<T>`) to allow shared references and `nil` representation.
            -   Direct References: For types that are already reference types in TypeScript (classes, arrays, maps).
            -   The `&` operator is translated to a varRefing operation or taking a reference. The `*` operator is translated to unvarRefing or dereferencing. This is handled in `compiler.WriteStarExpr` and `compiler.WriteUnaryExpr` (for `&`).
    -   **Dynamic Types (Interfaces):**
        -   **Go:** Interfaces store a (value, concrete_type) pair. Type assertions (`x.(T)`) and type switches check the concrete_type.
        -   **TypeScript:** Uses structural typing. Runtime type information is generally limited without explicit metadata.
        -   **Divergence:** GoScript needs to implement runtime mechanisms for Go-style type assertions and type switches. This typically involves:
            -   Storing type information (metadata) with interface values.
            -   `compiler.WriteTypeAssertExpr` and `compiler.WriteStmtTypeSwitch` generate calls to runtime helpers that use this metadata.

## Types

-   **Go Specification:**
    -   Definition: Determines a set of values, operations, and methods.
    -   Syntax: `Type = TypeName [ TypeArgs ] | TypeLit | "(" Type ")"`
        -   `TypeName = identifier | QualifiedIdent` (e.g., `int`, `pkg.MyType`)
        -   `TypeArgs = "[" TypeList [ "," ] "]"` (for generics, e.g., `List[int]`)
        -   `TypeLit` (e.g., `struct{ F int }`, `[]string`, `map[string]int`)
        -   `"(" Type ")"` (parenthesized type)

-   **GoScript & Divergences:**
    -   **General Mapping:** The core of GoScript is mapping Go types to TypeScript types.
        -   **Basic Types:** `bool` -> `boolean`, `string` -> `string`. Numeric types (`int`, `float64`, etc.) generally map to `number`, with `bigint` for `int64`/`uint64` or large integer constants. `rune` -> `number`. `byte` -> `number`.
        -   **Struct Types:** `struct { ... }` -> TypeScript `class { ... }` (as per `WriteStructTypeSpec`). This allows methods to be attached and provides a clear nominal type.
        -   **Interface Types:** `interface { ... }` -> TypeScript `interface { ... }` (as per `WriteInterfaceTypeSpec`). Go's implicit satisfaction via method sets maps well to TypeScript's structural typing.
        -   **Array Types:** `[N]T` -> `gs.Array<T>` (custom runtime class to preserve value semantics and fixed size) or potentially `T[]` if value semantics are not strictly needed or handled differently. `compiler.WriteArrayType` uses `gs.Array`.
        -   **Slice Types:** `[]T` -> `gs.Slice<T>` (custom runtime class). `compiler.WriteSliceType`.
        -   **Map Types:** `map[K]T` -> `gs.Map<K, T>` (custom runtime class) or `Map<K, T>` if keys are suitable. `compiler.WriteMapType` uses `gs.Map`.
        -   **Channel Types:** `chan T` -> `gs.Chan<T>` (custom runtime class). `compiler.WriteChannelType`.
        -   **Function Types:** `func(...) ...` -> TypeScript function types `(...) => ...`. `compiler.WriteFuncType`.
        -   **Pointer Types:** `*T` -> `gs.VarRef<T>` for varRefing, or the direct TypeScript reference type if `T` maps to a class. `compiler.WritePointerType`.
    -   **Type Names & Qualified Identifiers:**
        -   **Go:** `pkg.TypeName`.
        -   **TypeScript:** `import { TypeName } from 'pkg';` then `TypeName`.
        -   **Divergence:** GoScript manages imports and translates qualified identifiers to appropriate TypeScript module access or imported names. `compiler.WriteIdent` and import tracking in `GoToTSCompiler` handle this.
    -   **Generics (Type Parameters):**
        -   **Go (1.18+):** `func F[T any](p T) { ... }`, `type MyList[T any] []T`.
        -   **TypeScript:** `function F<T>(p: T) { ... }`, `type MyList<T> = T[]`.
        -   **Divergence:** Syntax differs but concepts are similar. GoScript translates Go generic syntax (type parameter lists, constraints) to TypeScript generic syntax. `compiler.WriteTypeExpr` and related functions for function/type declarations handle this. Constraint translation (e.g., Go interface constraints to TS `extends` clauses) is key.
    -   **Type Literals:** GoScript has dedicated functions to write each type literal (e.g., `WriteStructType`, `WriteArrayType`, etc.).
    -   **Parenthesized Type `(T)`:** Translated directly as `T` in TypeScript, parentheses usually preserved by the formatter if needed for precedence in complex type expressions.

### Boolean Types

-   **Go Specification:**
    -   Represents Boolean truth values: `true`, `false`.
    -   Predeclared type: `bool` (a defined type).

-   **GoScript & Divergences:**
    -   **Mapping:** Go `bool` maps directly to TypeScript `boolean`.
    -   **Values:** `true` and `false` map directly.
    -   **Divergence:** Minimal. TypeScript's `boolean` is a primitive type. Go's `bool` being a "defined type" implies distinctness from other potential boolean types if they could be defined, but in practice, this aligns well.

### Numeric Types

-   **Go Specification:**
    -   Integer types: `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `int32`, `int64`.
    -   Floating-point types: `float32`, `float64` (IEEE 754).
    -   Complex types: `complex64` (float32 parts), `complex128` (float64 parts).
    -   Aliases: `byte` for `uint8`, `rune` for `int32`.
    -   Implementation-specific size integers: `uint`, `int` (same size), `uintptr`.
    -   All numeric types are defined types and thus distinct (except aliases). Explicit conversions are required for mixing.

-   **GoScript & Divergences:**
    -   **Integer Mapping:**
        -   `int8`...`int32`, `uint8`...`uint32`: Map to TypeScript `number`.
        -   `int64`, `uint64`: Map to TypeScript `bigint` to preserve precision. GoScript runtime may need helpers for `bigint` operations if they are not directly translated by TS operators for all cases.
        -   `int`, `uint`: Typically map to `number`. GoScript assumes a 32-bit or 64-bit architecture for these; this should be configurable or based on Go's default.
        -   `uintptr`: Maps to `number` or `bigint`. Its primary use for pointer bits is abstracted by GoScript's pointer simulation.
        -   **Divergence:** TypeScript `number` has precision limits for integers (`Number.MAX_SAFE_INTEGER`). `bigint` handles larger integers. GoScript must ensure correct mapping and that operations on these types respect Go's semantics (e.g., overflow behavior for fixed-size integers if not using `bigint`). Currently, GoScript often maps to `number` and relies on standard arithmetic, which doesn't inherently enforce Go's fixed-size overflow. For `bigint`, operations are generally well-defined.
    -   **Floating-Point Mapping:**
        -   `float32`, `float64`: Map to TypeScript `number` (IEEE 754 64-bit double-precision).
        -   **Divergence:** `float32` will lose precision when mapped to `number`. This is a common trade-off.
    -   **Complex Mapping:**
        -   `complex64`, `complex128`: Map to a GoScript runtime type like `gs.Complex` (e.g., `{ real: number, imag: number }`).
        -   **Divergence:** TypeScript has no native complex types. All operations require runtime helper functions.
    -   **Type Distinctness:**
        -   **Go:** `int32` and `int` (even if `int` is 32-bit) are distinct types.
        -   **TypeScript:** `type MyInt = number; type MyInt32 = number;` does not make `MyInt` and `MyInt32` distinct in TypeScript's structural type system for primitives.
        -   **Divergence:** GoScript currently maps these to `number` or `bigint`. True type distinctness as in Go is not preserved at the TypeScript type system level for these basic numeric types without more complex mechanisms (like branding or wrapper classes, which GoScript does not currently use for basic types). This means `var i32 int32; var i int = int(i32)` becomes `let i32: number; let i: number = i32;` where Go required a conversion. GoScript relies on the Go type checker for correctness before translation.
    -   **`byte` and `rune`:**
        -   `byte` (alias for `uint8`) maps to `number`.
        -   `rune` (alias for `int32`) maps to `number`.
        -   This is consistent with their underlying types.

### String Types

-   **Go Specification:**
    -   Represents a set of string values; a string value is a (possibly empty) sequence of bytes.
    -   Immutable.
    -   Length via `len()`. Bytes accessible by integer indices `0` to `len(s)-1`.
    -   `&s[i]` (address of i'th byte) is illegal.
    -   Predeclared type: `string` (a defined type).

-   **GoScript & Divergences:**
    -   **Mapping:** Go `string` maps to TypeScript `string`.
    -   **Immutability:** Both are immutable.
    -   **Representation:**
        -   **Go:** Sequence of bytes, typically UTF-8 encoded.
        -   **TypeScript:** Sequence of UTF-16 code units.
        -   **Divergence:** While Go strings are byte sequences, the Go spec also says "string values are UTF-8 encoded". When GoScript translates a Go string literal or value to a TypeScript string, the conversion from UTF-8 (in Go) to UTF-16 (in TypeScript) is usually handled transparently by JavaScript engines. If a Go string contains arbitrary non-UTF-8 bytes, its representation or behavior in TypeScript could be problematic, but this is outside typical Go string usage.
    -   **Indexing and `len`:**
        -   Go `len(s)` gives byte length. TS `s.length` gives number of UTF-16 code units.
        -   Go `s[i]` gives the i-th byte. TS `s[i]` gives the i-th UTF-16 code unit (as a string).
        -   **Divergence:** For strings containing multi-byte UTF-8 characters (which become multiple UTF-16 code units, possibly surrogate pairs), `len` and indexing will yield different results/values. GoScript's `gs.len(s)` for strings should ideally return byte length if strict Go compatibility is needed for this, or this difference must be documented. Standard string iteration in Go (`for range s`) yields runes (Unicode code points), which GoScript aims to replicate.
    -   **`&s[i]`:** GoScript upholds the Go rule; taking the address of a string element is not possible.

### Array Types

-   **Go Specification:**
    -   Syntax: `[ArrayLength]ElementType` (e.g., `[32]byte`).
    -   `ArrayLength` must be a non-negative constant representable by `int`.
    -   Length is part of the array's type (e.g., `[3]int` and `[4]int` are different types).
    -   Value semantics: Assignments and parameter passing copy the entire array.
    -   Elements addressable by index `0` to `len(a)-1`.
    -   Cannot have an element of its own type (or a type containing it) if the containing types are only array or struct types (prevents direct recursive definition without pointers/interfaces/etc.).

-   **GoScript & Divergences:**
    -   **Mapping:** Go array `[N]T` maps to `gs.Array<T>` (a custom runtime class in `@goscript/builtin`).
        -   `compiler.WriteArrayType` generates `gs.Array<TranslatedElementType>`.
    -   **Value Semantics:** `gs.Array<T>` is designed to emulate Go's value semantics (e.g., by cloning on assignment/passing or by being an immutable structure that produces new instances on modification if that path were taken, though cloning is more direct for Go's model).
    -   **Fixed Length & Type Identity:**
        -   `gs.Array<T>` internally manages its fixed length, initialized based on `N`.
        -   **Divergence:** TypeScript's type system doesn't natively express fixed-length arrays as part of the type like `gs.Array<T, N>`. While `gs.Array<T>` is one generic type in TS, instances will behave as fixed-length. The distinction that `[3]int` and `[4]int` are different Go types is maintained by GoScript generating distinct instantiations or by relying on the Go type checker's information. The generated TypeScript might look like `gs.Array<number>` for both, but their construction and internal length differ.
    -   **Recursive Type Restriction:** This is primarily enforced by the Go compiler frontend. GoScript translates valid Go code.
    -   **Indexing:** `gs.Array<T>` provides methods for element access that correspond to Go's `a[i]`.

### Slice Types

-   **Go Specification:**
    -   Syntax: `[]ElementType` (e.g., `[]byte`).
    -   Descriptor for a contiguous segment of an underlying array.
    -   Properties: pointer to array, length, capacity.
    -   Uninitialized slice is `nil`.
    -   Length via `len()`, capacity via `cap()`. Length can change.
    -   Shares storage with its underlying array and other slices of the same array.

-   **GoScript & Divergences:**
    -   **Mapping:** Go slice `[]T` maps to `gs.Slice<T>` (a custom runtime class in `@goscript/builtin`).
        -   `compiler.WriteSliceType` generates `gs.Slice<TranslatedElementType>`.
    -   **`nil` Slices:** `gs.Slice<T>` must represent `nil` (e.g., an internal null pointer or a specific state).
    -   **Length, Capacity, Underlying Array:** `gs.Slice<T>` implements these concepts. It manages a reference to an underlying data store (which could be a `gs.Array<T>` or a standard TypeScript array internally) and tracks its own length and capacity.
    -   **Sharing Storage:** The implementation of `gs.Slice<T>` must ensure that operations like slicing one slice from another result in shared underlying data as per Go semantics.
    -   **`append`, `copy`:** These built-in Go functions for slices are implemented as methods or helper functions on/for `gs.Slice<T>` in the runtime.
    -   **Divergence:** The primary divergence is that these are custom classes in TypeScript, not native language constructs. Their correct implementation in `@goscript/builtin` is crucial for Go compatibility.

### Struct Types

-   **Go Specification:**
    -   Syntax: `struct { { FieldDecl ";" } }`.
    -   A sequence of named elements (fields), each with a name and type.
    -   Field names can be explicit (IdentifierList) or implicit (EmbeddedField).
    -   Non-blank field names within a struct must be unique.
    -   `FieldDecl = (IdentifierList Type | EmbeddedField) [ Tag ]`.
    -   `EmbeddedField = [ "*" ] TypeName [ TypeArgs ]`. The unqualified type name of `TypeName` acts as the field name. `TypeName` itself in an embedded field cannot be a pointer type or a type parameter.
    -   Fields and methods of an embedded field can be *promoted*.
    -   Promoted fields act like ordinary fields but cannot be used as field names in composite literals of the struct.
    -   Method set promotion rules for embedded `T` and `*T`.
    -   Field declarations can have an optional string literal `Tag`. Tags are visible via reflection, part of type identity, but otherwise ignored by the compiler.
    -   Recursive type restriction: A struct type `T` may not contain a field of type `T` (or a type containing `T` as a component) if containing types are only array or struct types.

-   **GoScript & Divergences:**
    -   **Mapping:** Go `struct { ... }` maps to TypeScript `class { ... }`.
        -   This is handled by `compiler.WriteStructTypeSpec`.
        -   Using a class provides a nominal type in TypeScript and a natural way to associate methods.
    -   **Fields:** Go struct fields map to TypeScript class properties.
        -   Blank identifier fields (e.g., `_ float32`) are translated as properties named `_` (e.g., `_: number`).
    -   **Embedded Fields & Promotion:**
        -   **Go:** `struct { T }` or `struct { *T }` promotes fields and methods of `T` to the embedding struct.
        -   **TypeScript:** No direct language feature for such field/method promotion from a property that represents an embedded type.
        -   **Divergence/GoScript Simulation:**
            -   **Fields:** GoScript simulates field promotion by explicitly declaring the promoted fields on the TypeScript class. The `compiler.spec.getEmbeddedFieldKeyName` function helps determine the name. When initializing, GoScript may flatten embedded struct initializers (see `compiler.spec-struct.generateFlattenedInitTypeString`).
            -   **Methods:** Methods from an embedded type `T` (or `*T`) are promoted. GoScript includes these in the method set of the generated class, typically by generating wrapper methods on the outer class that delegate to an instance of the embedded type (which itself is a field in the TypeScript class).
            -   **Composite Literals:** Go's rule that promoted fields cannot be directly used in composite literals of the outer struct needs to be respected. GoScript's `WriteCompositeLit` for structs should handle this by ensuring only explicitly defined fields of the outer struct (including the field representing the embedded struct itself) are initialized.
    -   **Field Name Uniqueness:** This is enforced by the Go compiler. GoScript translates valid Go code.
    -   **Tags:**
        -   **Go:** String literals associated with fields, used for reflection (e.g., `json:"name"`) and type identity.
        -   **TypeScript:** No direct language feature for struct field tags. Decorators could be a TS equivalent but are not currently used by GoScript for this.
        -   **Divergence:** GoScript generally discards tags during translation, as they are primarily for Go's runtime reflection system. If GoScript were to support reflection that uses tags, it would need a mechanism to store and access this metadata (e.g., as static properties on the class or via a separate metadata object). For type identity, GoScript relies on the Go type checker; the generated TypeScript structure doesn't carry tag information for TS-level type checking in a way that mirrors Go's type identity rules regarding tags.
    -   **Recursive Type Restriction:** Enforced by the Go compiler. GoScript translates valid Go code.

### Pointer Types

-   **Go Specification:**
    -   Syntax: `*BaseType` (e.g., `*int`).
    -   Denotes the set of all pointers to variables of `BaseType`.
    -   The value of an uninitialized pointer is `nil`.

-   **GoScript & Divergences:**
    -   **Mapping:** Go `*T` is mapped by `compiler.WritePointerType`.
        -   If `T` maps to a TypeScript primitive or a Go struct (which becomes a TS class designed for value semantics), `*T` typically maps to `gs.VarRef<TranslatedT>` from `@goscript/builtin`. This wrapper simulates indirection, shared mutability, and `nil`.
        -   If `T` maps to a TypeScript class that is already a reference type (e.g., for Go interface types, or Go slices/maps which map to `gs.Slice`/`gs.Map` runtime classes), `*T` might map directly to `TranslatedT` (which can be `null`) or a more specific pointer wrapper if needed to distinguish `*MyClass` from `MyClass` when `MyClass` itself can be `nil`.
    -   **`nil` Value:** `gs.VarRef<T>` can be `null` (or have an internal `null` value) to represent Go's `nil` pointer. Standard TypeScript reference types can also be `null`.
    -   **Dereferencing (`*p`):** Translated to `p.value` for `gs.VarRef` or direct access if `p` is a direct reference.
    -   **Address-of (`&v`):** Translated to `new gs.VarRef(v)` for values needing varRefing, or taking the reference directly if `v` is already a reference type suitable for Go's pointer semantics in that context.
    -   **Divergence:** Fundamental. TypeScript lacks Go's explicit memory addresses and pointer arithmetic. GoScript simulates pointer semantics through varRefing and reference management. `unsafe.Pointer` is a significant challenge and generally unsupported or highly restricted.

### Function Types

-   **Go Specification:**
    -   Syntax: `func Signature` (e.g., `func(int) bool`).
    -   `Signature = Parameters [ Result ]`.
    -   `Parameters = "(" [ ParameterList [ "," ] ] ")"`.
    -   `ParameterDecl = [ IdentifierList ] [ "..." ] Type`.
        -   Names in parameter/result lists must be all present or all absent. Non-blank names must be unique.
    -   Final parameter can be variadic (`...Type`).
    -   Value of an uninitialized function type variable is `nil`.

-   **GoScript & Divergences:**
    -   **Mapping:** Go `func(P1, P2) (R1, R2)` maps to a TypeScript function type `(p1: tsP1, p2: tsP2) => tsR` where `tsR` is a single type (e.g., `void` if no results, `tsR1` if one result, or an object/tuple for multiple results).
        -   Handled by `compiler.WriteFuncType` and `compiler.WriteSignatureType`.
    -   **Parameters:**
        -   Named/unnamed: TypeScript supports this directly.
        -   Variadic: Go `...T` maps to TypeScript `...tsT[]` (rest parameters). Spread `s...` maps to `...s_ts`.
    -   **Results:**
        -   Single result: `func() int` -> `() => number`.
        -   Multiple results: `func() (int, string)` -> `() => [number, string]` (if unnamed) or `() => {res1: number, res2: string}` (if named). GoScript uses an array for unnamed multiple results and an object for named multiple results.
    -   **`nil` Function Value:** Go function variables can be `nil`. TypeScript function-typed variables can be `null` or `undefined`. GoScript should consistently map Go `nil` function values to `null` in TypeScript.
    -   **Divergence:** The primary structural divergence is the handling of multiple return values, which requires a convention (array or object) in TypeScript. The concept of a `nil` function maps to `null`.

### Interface Types

-   **Go Specification:**
    -   Syntax: `interface { { InterfaceElem ";" } }`.
    -   `InterfaceElem = MethodElem | TypeElem`.
    -   `MethodElem = MethodName Signature`. Method names unique and non-blank.
    -   `TypeElem = TypeTerm { "|" TypeTerm }` (union of type terms).
    -   `TypeTerm = Type | UnderlyingType` (e.g., `~string`).
    -   Defines a *type set*. A variable of interface type can hold any value whose type is in this set (implements the interface).
    -   Value of an uninitialized interface variable is `nil`.
    -   **Basic Interfaces:** Only method elements. Type set includes types implementing all methods.
    -   **Embedded Interfaces (Go 1.14+):** `interface T { E }` where `E` is an interface. Type set of `T` is intersection of `T`'s explicit methods and `E`'s type set.
    -   `interface{}` (empty interface) or `any` (alias, Go 1.18+): Represents the set of all types.

-   **GoScript & Divergences:**
    -   **Mapping (Basic Interfaces):** Go `interface { M1(); M2() }` maps to TypeScript `interface { M1(): void; M2(): void; }` (or equivalent type alias).
        -   Handled by `compiler.WriteInterfaceTypeSpec`.
        -   Go's implicit satisfaction of interfaces by types having the required methods aligns well with TypeScript's structural typing.
    -   **`nil` Interface Value:** Go interface variables can be `nil`. TypeScript variables of an interface type can be `null` or `undefined`. GoScript maps Go `nil` interface values to `null`.
    -   **`interface{}` / `any`:** Maps to TypeScript `any`.
    -   **Embedded Interfaces:**
        -   Go: `type ReadWriter interface { Reader; Writer }`.
        -   TypeScript: `interface ReadWriter extends Reader, Writer {}` or by explicitly listing all methods. GoScript typically generates interfaces with all methods explicitly listed.
    -   **Type Elements (for constraints/unions, Go 1.18+):**
        -   Go: `interface { int | string }` or `interface { ~string }`.
        -   TypeScript: Union types like `number | string` are a direct parallel for simple unions. `~string` (type whose underlying type is string) is primarily for generic constraints in Go. Representing arbitrary `TypeElem` sets in TypeScript interfaces beyond simple unions can be complex. GoScript's `WriteInterfaceTypeSpec` primarily focuses on method sets.
    -   **Runtime Behavior (Type Assertions/Switches):**
        -   Go interfaces store `(value, concrete_type)` pair.
        -   TypeScript interfaces are compile-time constructs; no runtime type information.
        -   **Divergence:** This is a major area. GoScript implements runtime type information (`gs.typeInfo` attached to values or `gs.VarRef`) and helper functions (`gs.typeAssert`, `gs.typeSwitch`) to emulate Go's type assertions (`x.(T)`) and type switches. This is handled by `compiler.WriteTypeAssertExpr` and `compiler.WriteStmtTypeSwitch`.
    -   **Method Set Calculation:** Go has specific rules for method sets (e.g., `T` vs. `*T`). GoScript must ensure that method calls on interface values correctly resolve based on these rules, often involving the runtime type information.
    -   **General Interfaces (Type Elements & Unions - Go 1.18+):**
        -   **Go:** Interfaces can include type elements (e.g., `int`), underlying type terms (e.g., `~string`), and unions of these (e.g., `~int | ~float64`). These are primarily used for defining type constraints for generics.
        -   **Go:** Interfaces that are not "basic" (i.e., contain type elements beyond simple method sets or embeddings of basic interfaces) cannot be the types of variables or values directly; they are restricted to use as constraints.
        -   **TypeScript:** Has union types (`A | B`) and advanced conditional/mapped types that can express complex constraints. Generic constraints use `extends`.
        -   **Divergence/GoScript Approach:**
            -   When these general interfaces are used as type constraints in Go generics, GoScript translates them into corresponding TypeScript generic constraints (e.g., using `extends` with union types or other structural definitions).
            -   Direct translation of a Go general interface (like `interface{~int | ~string}`) into a standalone TypeScript type that can be used for variables is complex if it's not a basic interface. GoScript's `WriteInterfaceTypeSpec` focuses on basic interfaces (method sets). If GoScript encounters a non-basic interface used in a way Go permits (e.g., as a constraint), it will handle it in the context of that usage (e.g., generic parameter constraint translation). The restriction that non-basic interfaces cannot be types of variables in Go means GoScript doesn't typically need to form a direct, usable TypeScript variable type from them, but rather use their definition to constrain a generic type parameter.

### Map Types

-   **Go Specification:**
    -   Syntax: `map[KeyType]ElementType`.
    -   Unordered group of elements of `ElementType`, indexed by unique keys of `KeyType`.
    -   Uninitialized map is `nil`.
    -   `KeyType` must be comparable (not function, map, or slice). Interface key types must have comparable dynamic values.
    -   Operations: `len()`, assignment for add/update, index expression for retrieval, `delete()`, `clear()`.
    -   Created with `make(map[KeyType]ElementType, [capacityHint])`.
    -   `nil` map is like an empty map but no elements can be added.

-   **GoScript & Divergences:**
    -   **Mapping:** Go `map[K]V` is mapped by `compiler.WriteMapType` to `gs.Map<tsK, tsV>` (a custom class in `@goscript/builtin`).
    -   **`nil` Value:** `gs.Map` instances can be `null` to represent Go's `nil` map.
    -   **Key Comparability:**
        -   Go's strict rules for key comparability (especially for structs or arrays as keys) require careful handling. `gs.Map` needs to use a robust internal mechanism for key hashing and equality that mirrors Go's semantics (e.g., for struct keys, all fields are compared; for array keys, elements are compared).
        -   TypeScript's built-in `Map` uses `SameValueZero` for key equality, which works for primitives and object references. For Go's value-based key semantics with complex types, `gs.Map` must implement custom key management.
        -   **Divergence:** Significant. TypeScript's `Map` keying is reference-based for objects. `gs.Map` must simulate Go's value-based keying, potentially by serializing or deeply comparing complex keys, which can have performance implications.
    -   **Operations:**
        -   `len(m)` -> `m.len()` or `m.size`.
        -   `m[key] = val` -> `m.set(key, val)`.
        -   `val = m[key]` -> `val = m.get(key)`.
        -   `delete(m, key)` -> `m.delete(key)`.
        -   `clear(m)` -> `m.clear()`.
        -   `v, ok := m[key]` -> `[v, ok] = m.getWithOk(key)` or similar pattern.
    -   **Iteration Order:** Go map iteration order is explicitly undefined. TypeScript `Map.prototype.forEach` and `for...of` iteration preserve insertion order. `gs.Map` should ideally mimic Go's undefined order if strict adherence is required, or document this divergence if it uses TS `Map`'s ordering.

### Channel Types

-   **Go Specification:**
    -   Syntax: `chan ElementType`, `chan<- ElementType` (send-only), `<-chan ElementType` (receive-only).
    -   Mechanism for concurrent functions to communicate by sending/receiving values.
    -   Uninitialized channel is `nil`.
    -   Created with `make(chan ElementType, [bufferCapacity])`.
        -   Capacity 0 (default): unbuffered (sender and receiver must be ready).
        -   Capacity > 0: buffered (send/receive can proceed if buffer not full/empty).
    -   `nil` channel is never ready for communication.
    -   Operations: `close()`, send (`ch <- val`), receive (`val <- ch`, `val, ok <- ch`).
    -   FIFO queue.

-   **GoScript & Divergences:**
    -   **Mapping:** Go `chan T` is mapped by `compiler.WriteChannelType` to `gs.Channel<tsT>` (a custom class in `@goscript/builtin`).
    -   **Concurrency Model:**
        -   **Go:** Goroutines and channels are fundamental to Go's concurrency.
        -   **TypeScript/JavaScript:** Single-threaded event loop with `async/await` for asynchronous operations. True parallelism typically involves Web Workers or Node.js worker threads.
        -   **Divergence:** This is the most significant divergence. GoScript cannot directly replicate Go's goroutine-based concurrency and channel semantics in standard browser/Node.js JavaScript. `gs.Channel` would likely be implemented using `async/await` and promises to simulate blocking operations, but it operates within the JS event loop model.
    -   **`nil` Channel:** `gs.Channel` instances can be `null`.
    -   **Buffering:** `gs.Channel` must simulate buffered and unbuffered behavior.
        -   Unbuffered: A send operation would await a corresponding receive, and vice-versa.
        -   Buffered: Sends complete if buffer not full, receives complete if buffer not empty.
    -   **Operations:**
        -   `close(ch)` -> `ch.close()`.
        -   `ch <- val` -> `await ch.send(val)`.
        -   `val = <-ch` -> `val = await ch.receive()`.
        -   `val, ok = <-ch` -> `[val, ok] = await ch.receiveWithOk()`.
    -   **Select Statement:** Go's `select` statement, which waits on multiple channel operations, is a complex construct. Translating it (`compiler.WriteStmtSelect`) requires a sophisticated mechanism in `gs.Channel` or a helper (e.g., `gs.select`) to manage multiple asynchronous operations and choose the first one ready, mimicking Go's selection rules (including randomization for multiple ready channels).
    -   **Directionality:** `chan<-` and `<-chan` are compile-time checks in Go. GoScript can enforce this at the TypeScript type level to some extent (e.g., by providing different interfaces or views of `gs.Channel`).
    -   **Limitations:** True goroutine preemption and scheduling are beyond GoScript's scope. The behavior of `gs.Channel` will be an approximation within the JavaScript concurrency model. This means that code relying on fine-grained goroutine interleaving or specific scheduler behaviors may not translate perfectly.

## Properties of Types and Values

### Underlying types

-   **Go Specification:**
    -   Every type `T` has an underlying type.
    -   If `T` is a predeclared boolean, numeric, string type, or a type literal, its underlying type is `T` itself.
    -   Otherwise, `T`'s underlying type is the underlying type of the type to which `T` refers in its declaration.
    -   For a type parameter, its underlying type is the underlying type of its type constraint (which is always an interface).
    -   Example:
        ```go
        type A1 = string // underlying type of A1 is string
        type B1 string   // underlying type of B1 is string
        type B2 B1      // underlying type of B2 is string
        type B3 []B1    // underlying type of B3 is []B1
        ```

-   **GoScript & Divergences:**
    -   **Mapping:** GoScript needs to track underlying types, especially for type identity and assignability rules.
    -   **Type Aliases (`type A1 = string`):** In Go, `A1` and `string` are identical. TypeScript type aliases (`type A1 = string`) behave similarly. This should map directly. `compiler.WriteTypeSpec` handles type aliases by writing the aliased type.
    -   **Type Definitions (`type B1 string`):** In Go, `B1` is a new type, distinct from `string`, though its underlying type is `string`. TypeScript can achieve this distinction using "branded types" or nominal typing emulation (e.g., `type B1 = string & { __brand: 'B1' }`) or by wrapping them in classes if more distinct behavior is needed.
        -   Currently, `compiler.WriteTypeSpec` for a defined type like `type B1 string` generates `type B1 = string`. This is a **divergence**. `B1` and `string` become identical in TypeScript, losing the distinction Go provides.
        -   To fix this, GoScript would need to implement a strategy for nominal typing for defined types that are not structs or interfaces (which naturally become classes/interfaces).
    -   **Generics/Type Parameters:** The concept of an underlying type for a type parameter (being its constraint's underlying type) is relevant for Go's type system. TypeScript's generics have similar concepts with constraints. This should be manageable if the constraint types themselves are correctly mapped.

### Type identity

-   **Go Specification:**
    -   Two types are either identical or different.
    -   A named type is always different from any other type (unless it's an alias).
    -   Two unnamed types are identical if their underlying type literals are structurally equivalent:
        -   **Array types:** Identical element types and same length.
        -   **Slice types:** Identical element types.
        -   **Struct types:** Same sequence of fields, corresponding fields have same names, identical types, identical tags, and both embedded or not. Non-exported field names from different packages are always different.
        -   **Pointer types:** Identical base types.
        -   **Function types:** Same number of params/results, corresponding types identical, both variadic or not. Names don't matter.
        -   **Interface types:** Define the same type set (i.e., same methods with identical signatures).
        -   **Map types:** Identical key and element types.
        -   **Channel types:** Identical element types and same direction.
        -   **Instantiated types:** Defined types and all type arguments are identical.
    -   Examples:
        -   `type A0 = []string` and `[]string` are identical.
        -   `type B0 []string` and `[]string` are different.

-   **GoScript & Divergences:**
    -   **Structural vs. Nominal Typing:** TypeScript is primarily structurally typed. Go has a mix: named types introduce nominality, while unnamed type literals are structural.
    -   **Named Types:**
        -   **Go:** `type MyInt int` makes `MyInt` different from `int`.
        -   **GoScript (Current):** `compiler.WriteTypeSpec` often generates `type MyInt = number`. This makes `MyInt` and `number` structurally identical, a **divergence**.
        -   To align, GoScript would need to enforce nominal typing for Go's named types, possibly through branding or class wrappers, as mentioned for "Underlying types".
    -   **Struct Types:**
        -   Go's rules for struct identity (field names, types, tags, embedded status, export status of names from different packages) are quite specific.
        -   TypeScript's structural typing for objects/classes compares property names and types. It doesn't have a direct concept of "tags" or "embedded" in the same way for identity, nor package-based name differentiation for unexported fields.
        -   **Divergence:** GoScript's generated classes/interfaces for structs will be compared structurally by TypeScript. This might lead to types being considered identical by TypeScript where Go would consider them different (e.g., if tags differ, or if unexported field names from different Go packages happen to be the same). The reverse could also occur if GoScript mangles names in a way that makes structurally similar Go structs appear different in TypeScript.
    -   **Interface Types:**
        -   Go: Identical if they define the same type set (methods).
        -   TypeScript: Interfaces are structurally typed. If they have the same members (methods and properties) with compatible types, they are compatible and often considered "identical" in practice for assignability.
        -   **Divergence:** Generally aligns well due to TypeScript's structural nature for interfaces. GoScript's `compiler.WriteInterfaceTypeSpec` generates TS interfaces.
    -   **Function Types:**
        -   Go: Parameter/result counts and types, variadic status. Names don't matter.
        -   TypeScript: Similar rules for function type compatibility.
        -   **Divergence:** Should map well.
    -   **Pointer, Array, Slice, Map, Channel Types:** Identity depends on their element/base types. This structural approach should map reasonably to TypeScript's type system if the constituent types are mapped correctly.
        -   `gs.Pointer<T>`, `gs.Slice<T>`, `gs.Map<K, V>`, `gs.Channel<T>` would be generic types. `gs.Pointer<number>` and `gs.Pointer<MyInt>` would be different if `number` and `MyInt` are different.
    -   **Instantiated Generic Types:**
        -   Go: `D0[int, string]` and `E0 = D0[int, string]` are identical if `D0` is a defined generic type.
        -   TypeScript: `D0<number, string>` and `type E0 = D0<number, string>` are identical. This aligns.

### Assignability

-   **Go Specification:**
    -   A value `x` of type `V` is assignable to a variable of type `T` if:
        1.  `V` and `T` are identical.
        2.  `V` and `T` have identical underlying types (but are not type parameters), and at least one of `V` or `T` is not a named type. (e.g., `type MyInt int; var i int; var m MyInt; i = m` is invalid. `type MySlice []int; var s []int; var ms MySlice; s = ms` is valid because `[]int` is unnamed).
        3.  `T` is an interface type (not a type parameter) and `x` implements `T`.
        4.  `V` and `T` are channel types with identical element types, `V` is bidirectional, and at least one of `V` or `T` is not a named type.
        5.  `x` is `nil` and `T` is a pointer, function, slice, map, channel, or interface type (not a type parameter).
        6.  `x` is an untyped constant representable by a value of type `T`.
    -   Additional rules for type parameters:
        7.  `x` is `nil`, `T` is a type parameter, and `x` is assignable to each type in `T`'s type set.
        8.  `V` is not a named type, `T` is a type parameter, and `x` is assignable to each type in `T`'s type set.
        9.  `V` is a type parameter, `T` is not a named type, and values of each type in `V`'s type set are assignable to `T`.

-   **GoScript & Divergences:**
    -   **Rule 1 (Identical Types):** If GoScript correctly implements Go's type identity (see above), this rule should follow. **Divergence** exists if GoScript treats Go's distinct named types as identical TypeScript types (e.g., `type MyInt int` -> `type MyInt = number`).
    -   **Rule 2 (Identical Underlying Types, one unnamed):**
        -   This rule is crucial for Go's type system, allowing assignment between a named type and an unnamed type if their underlying structures match (e.g., `type MySlice []int; var s []int; var ms MySlice = []int{}; s = ms` is valid).
        -   **GoScript (Current):** If `type MySlice []int` becomes `type MySlice = number[]` and `s` is `number[]`, then they are identical, and assignment works. This "works" but for the wrong reason (they are identical, not just assignable due to underlying types).
        -   If GoScript implements nominal typing for `MySlice` (e.g., `MySlice = number[] & {__brand: 'MySlice'}`), then `MySlice` and `number[]` are not identical. TypeScript's assignability would then depend on its structural rules. `MySlice` would be assignable to `number[]` because it has all properties of `number[]`. `number[]` would *not* be assignable to `MySlice` without a cast. This matches Go's behavior (`s = ms` is OK, `ms = s` is not OK without a conversion `ms = MySlice(s)`).
        -   **Potential Divergence:** Careful implementation of nominal types and checking TypeScript's assignability rules is needed.
    -   **Rule 3 (Interface Implementation):**
        -   Go: `x` implements `T` if `x`'s type has all methods of `T`.
        -   TypeScript: Structural typing for interfaces means if an object (or class instance) has the members of an interface, it's assignable.
        -   **Divergence:** Generally aligns well. GoScript generates TS interfaces for Go interfaces.
    -   **Rule 4 (Channel Assignability):**
        -   Involves element types, direction, and one unnamed type.
        -   GoScript's `gs.Channel<T>` would need to handle this. If `gs.ChannelSend<T>` and `gs.ChannelRecv<T>` are distinct types from `gs.Channel<T>`, TypeScript's assignability rules would apply. A bidirectional `gs.Channel<T>` should be assignable to `gs.ChannelSend<T>` and `gs.ChannelRecv<T>` (if they are supertypes or structurally compatible).
        -   **Divergence:** Depends on the `gs.Channel` design.
    -   **Rule 5 (`nil` Assignability):**
        -   Go: `nil` assignable to pointers, functions, slices, maps, channels, interfaces.
        -   TypeScript: `null` (or `undefined`) assignable to types that include `null` (e.g., `string | null`).
        -   **Divergence:** GoScript maps Go `nil` to TS `null`. The target TS type must be nullable (e.g., `gs.Pointer<T> | null`, `gs.Slice<T> | null`). This is generally manageable.
    -   **Rule 6 (Untyped Constants):**
        -   Go: Untyped constants can be implicitly converted.
        -   TypeScript: Literals have types (e.g., `42` is `number`, `"foo"` is `string`).
        -   **Divergence:** GoScript relies on the Go compiler frontend to resolve types of constants in expressions. When writing the TS code, the constant will have a concrete TS type (`number`, `string`, `boolean`). The flexibility of Go's untyped constants (e.g., an untyped integer constant being assignable to `int8`, `float64`, etc., if representable) is handled before GoScript's translation phase. The translated code will deal with typed values.
    -   **Rules 7-9 (Type Parameters):** These involve assignability with generic type parameters and their constraints. TypeScript's generic system has its own complex assignability rules based on constraints.
        -   **Divergence:** This is a complex area. GoScript needs to ensure that the translation of Go generics to TypeScript generics preserves assignability as much as possible. This will depend heavily on how type constraints are translated and how TypeScript evaluates assignability for generic types. For example, `x` assignable to each type in `T`'s type set (if `T` is a union of types due to its constraint) needs careful mapping.

### Representability

-   **Go Specification:**
    -   Defines if a constant `x` can be represented by a value of type `T` (not a type parameter).
    -   Conditions:
        1.  `x` is in the set of values determined by `T`.
        2.  `T` is a floating-point type, and `x` can be rounded to `T`'s precision without overflow (IEEE 754 round-to-even).
        3.  `T` is a complex type, and `real(x)` and `imag(x)` are representable by `T`'s component type.
    -   If `T` is a type parameter, `x` must be representable by each type in `T`'s type set.
    -   Examples: `'a'` by `byte`, `1024` by `int16`, `42.0` by `byte`, `2.71...` by `float32` (with rounding).
    -   Not representable: `0` by `bool`, `1024` by `byte` (overflow), `1.1` by `int`.

-   **GoScript & Divergences:**
    -   **Compile-time Check in Go:** Representability is primarily a Go compile-time concern, handled by the Go type checker before GoScript's translation phase. GoScript receives AST and type information where constants are already typed and their representability has been confirmed in their Go context.
    -   **Numeric Precision:**
        -   Go has various fixed-size integer types (e.g., `int8`, `int64`) and specific float types (`float32`, `float64`).
        -   TypeScript primarily uses `number` (IEEE 754 double-precision float) and `bigint` for arbitrary-precision integers.
        -   When GoScript translates a Go constant (which the Go compiler has already deemed representable for its Go type), it will write it as a TypeScript literal.
            -   Example: `const c byte = 42.0`. Go allows this; `42.0` is representable as `42` in `byte`. GoScript translates this to `const c: number = 42`.
            -   Example: `const f float32 = 2.718281828459045`. Go rounds this to the nearest `float32` value. GoScript would translate this rounded value to a TS `number`.
        -   **Divergence:** The main potential for divergence lies in whether the TypeScript `number` type can precisely hold the *exact* value that Go determined after its representability rules (including rounding for floats). For most common values, this is fine. For very large integers outside `BigInt`'s explicit use, or extreme floating-point precision scenarios, subtle differences might arise if Go's internal high-precision constant arithmetic results in a value that TypeScript's `number` then re-approximates. However, GoScript translates the *final typed value* from Go.
    -   **Untyped Constants:** Go's rules for untyped constants (which are implicitly converted and checked for representability when assigned or used in a typed context) are handled by the Go compiler. GoScript will see the constant in its typed context.

### Method sets

-   **Go Specification:**
    -   Determines methods callable on an operand.
    -   Defined type `T`: methods with receiver `T`.
    -   Pointer `*T` (where `T` is not pointer/interface): methods with receiver `*T` or `T`. (e.g., if `T` has `M_T()` and `*T` has `M_star_T()`, then `*T`'s method set includes both).
    -   Interface type: intersection of method sets of types in its type set (usually its explicitly declared methods).
    -   Structs with embedded fields: methods of embedded fields may be promoted.
    -   Each method in a set must have a unique non-blank name.

-   **GoScript & Divergences:**
    -   **Mapping:** Go methods (`func (recv ReceiverType) MethodName(...)`) are translated by `compiler.WriteFuncDeclAsMethod` to TypeScript class methods. The receiver becomes `this`.
    -   **Value vs. Pointer Receivers:**
        -   Go: `(t T)` (value receiver), `(t *T)` (pointer receiver).
            -   Methods with `T` receivers can be called on values of type `T` or pointers `*T`.
            -   Methods with `*T` receivers can be called on pointers `*T`. Go also allows calls on addressable values of type `T` (e.g., `var v T; v.PtrMethod()` becomes `(&v).PtrMethod()`).
        -   TypeScript: Class methods operate on `this`. There's no direct TS syntax to distinguish method definition by value/pointer receiver. All methods are defined on the class prototype.
        -   **GoScript (Current):** All methods (both value and pointer receiver) are generated on the TypeScript class corresponding to `T`.
            -   Calls on `T` instances: `t_instance.Method()`.
            -   Calls on `gs.Pointer<T>` instances: `ptr_t_instance.value.Method()`. GoScript's `compiler.WriteSelectorExpr` needs to handle the `.value` access automatically for `gs.Pointer` types when calling methods.
            -   **Divergence (Addressability for Pointer Receivers):** Go's automatic taking of address for pointer receiver calls on addressable values (e.g., `v.PtrMethod()` where `v` is `T`) is a subtle point. In TypeScript, if `v_ts` is an instance of class `T_ts`, `v_ts.PtrMethod()` would just call the method. The "pointer" nature of the original Go receiver is not directly enforced by TypeScript at the call site in the same way unless `v_ts` itself is explicitly a `gs.Pointer`. GoScript aims to make method calls work transparently where Go allows them.
            -   This means if Go code is `var t T; t.PointerReceiverMethod()`, and `PointerReceiverMethod` is `func (t *T) ...`, Go makes it `(&t).PointerReceiverMethod()`. GoScript would translate `t` to a TS class instance. The call `t_ts.PointerReceiverMethod()` would execute. The method body in TS would operate on `this` (the `t_ts` instance). This largely works but doesn't replicate the memory/pointer semantics precisely.
    -   **Interface Method Sets:**
        -   Go interfaces define a set of method signatures. Types implement interfaces implicitly by having those methods.
        -   TypeScript interfaces also define a shape (methods, properties). Classes can implement them structurally.
        -   **Divergence:** This aligns well due to TypeScript's structural typing. `compiler.WriteInterfaceTypeSpec` generates TS interfaces.
    -   **Embedded Fields and Promoted Methods:**
        -   Go: Methods of an embedded field are "promoted" to the embedding struct if there's no conflict.
        -   TypeScript: No direct language feature for method promotion via embedding. Composition is used, requiring explicit delegation.
        -   **Divergence (Significant):** To mimic method promotion, GoScript's `compiler.WriteStructTypeSpec` would need to explicitly generate wrapper methods on the outer class that delegate calls to the embedded field's instance. This can be complex, especially with multiple levels of embedding or pointer vs. value embedded fields. This is a known area for advanced implementation.
    -   **Method Uniqueness:** Checked by the Go compiler.

## Blocks

-   **Go Specification:**
    -   A sequence of declarations and statements within `{ ... }`.
    -   Implicit blocks:
        1.  Universe block (all Go source).
        2.  Package block (all Go source for a package).
        3.  File block (all Go source in a file).
        4.  Each `if`, `for`, `switch` statement is in its own implicit block.
        5.  Each clause in `switch` or `select` acts as an implicit block.
    -   Blocks nest and influence scope.

-   **GoScript & Divergences:**
    -   **Mapping:** Go explicit blocks `{...}` map directly to TypeScript blocks `{...}`.
    -   **Scoping:** The primary impact of blocks is on lexical scoping.
        -   Universe block (predeclared identifiers): Handled by GoScript using `@goscript/builtin` imports or direct TypeScript equivalents (e.g., `true`, `false`).
        -   Package/File blocks: Map to TypeScript module scope (as each file is a module).
        -   `if`, `for`, `switch` blocks: TypeScript has these control flow structures, and `let`/`const` declarations within them are block-scoped.
    -   **Divergence:** Generally aligns well. TypeScript's block scoping with `let` and `const` behaves similarly to Go's block scoping for variables declared within those blocks.

## Declarations and scope

-   **Go Specification:**
    -   A declaration binds a non-blank identifier to a constant, type, type parameter, variable, function, label, or package.
    -   Identifiers must be declared. No identifier declared twice in the same block (except for `init` and blank identifier).
    -   Lexical Scoping:
        -   Predeclared identifiers: universe scope.
        -   Top-level (package-level) const, type, var, func: package scope.
        -   Imported package name: file scope of the import declaration.
        -   Method receiver, func parameters, result variables: function body scope.
        -   Type parameter of func/method: scope from after func name to end of func body.
        -   Type parameter of type decl: scope from its `IDENTIFIER` in `TypeParamDecl` to end of `TypeSpec`.
        -   Const/var/func declared in a function: scope from `IDENTIFIER` in `ConstSpec`/`VarSpec` or `FunctionLit` to end of innermost containing block.
        -   Label: scope is the body of the function in which it's declared, excluding nested functions.

-   **GoScript & Divergences:**
    -   **Mapping Declarations:**
        -   Go `const`, `var` -> TypeScript `const`, `let`.
        -   Go `func` -> TypeScript `function` or class methods.
        -   Go `type` (aliases, definitions) -> TypeScript `type`, `class`, `interface`.
    -   **Scoping:**
        -   **Lexical Scoping:** TypeScript's `let` and `const` are block-scoped, aligning well with Go's lexical scoping rules for variables.
        -   **Package Scope:** Go declarations at package level map to TypeScript module-level declarations (possibly exported).
        -   **Function Scope:** Parameters and variables declared within a Go function map to parameters and `let`/`const` variables within a TypeScript function/method, which have appropriate function or block scope.
        -   **Hoisting:**
            -   Go `var` declarations are hoisted (conceptually moved to the top of their function block, initialized with zero value). Go function declarations are also hoisted.
            -   TypeScript `var` is hoisted. TypeScript `let`, `const`, `class`, and `function` declarations are block-scoped. `let`/`const`/`class` are not accessible before their lexical declaration (Temporal Dead Zone - TDZ). `function` declarations are hoisted.
            -   **Divergence:** GoScript translates Go `var` to TS `let`. If Go code relies on `var` hoisting (using a variable before its textual declaration within the same function scope but after the function start), this could behave differently with `let` (TDZ error). However, good Go practice usually avoids such uses. For Go function hoisting, TS function hoisting is similar.
        -   **Short Variable Declarations (`:=`):**
            -   `v := expr` declares `v` if new in the current block, or assigns if `v` exists in an outer block and is redeclared in an inner block (shadowing).
            -   `a, b := f()`: If `a` is new in the current block and `b` was declared in an outer block, Go declares `a` and re-assigns to the outer `b` (if `b` is not also shadowed in the current block by this statement). This specific multi-assignment with mixed declaration/re-assignment is complex.
            -   `compiler.WriteStmtAssign` (for `token.DEFINE`) translates `:=`. It must correctly use `let` for newly declared variables in the current scope and direct assignment for variables pre-existing in an accessible scope.
            -   **Divergence:** TypeScript does not have a single statement that both declares some variables and reassigns others that are already in scope quite like Go's `:=` in all its nuances (especially the "redeclared in outer block" part for multi-value assignments). GoScript must decompose this: `let newVar1; ... newVarN; newVar1 = ...; existingVar1 = ...;`. The `analysis` package helps identify new vs. existing variables.
        -   **`init` functions:** Go `init` functions are special (executed per package before `main`). GoScript's `compiler.Compile` collects these. They need to be invoked appropriately in the generated TS module (e.g., called automatically when the module loads).
        -   **Blank Identifier (`_`):**
            -   `_ = f()`: Calls `f()` for side effects. Maps to `_ = f()` or just `f()` in TS.
            -   `_ := f()`: Calls `f()`, discards value, doesn't declare `_`.
        -   **Type Parameter Scope:** Should align if generic constructs are mapped correctly.
        -   **Label Scope:** Go labels are function-scoped for `goto`, `break LABEL`, `continue LABEL`. TypeScript does not have `goto`. Labeled `break`/`continue` exist for loops/blocks. `compiler.WriteStmtBranch` handles `break`/`continue`, potentially with labels. `goto` is a major divergence (often disallowed or translated with complex state machines if attempted).

### Label scopes

-   **Go Specification:**
    -   Labels are declared by labeled statements (e.g., `myLabel: for ...`).
    -   Used by `break`, `continue`, `goto`.
    -   Illegal to define an unused label.
    -   Labels are not block-scoped and don't conflict with non-label identifiers.
    -   Scope: The body of the function in which it's declared, excluding nested function bodies.

-   **GoScript & Divergences:**
    -   **`goto`:** TypeScript does not have `goto`.
        -   **Divergence (Major):** GoScript cannot directly translate `goto`. This is a fundamental limitation. Code using `goto` would require significant refactoring to be translatable or would be unsupported. `compiler.WriteStmtBranch` for `token.GOTO` currently notes it's not implemented.
    -   **Labeled `break` and `continue`:**
        -   Go: `break myLabel`, `continue myLabel`.
        -   TypeScript: Supports labeled `break` and `continue` for loops and blocks.
        -   **GoScript:** `compiler.WriteStmtBranch` handles these for `token.BREAK` and `token.CONTINUE`. This should map well.
    -   **Label Scope and Conflicts:** TypeScript label scopes are similar (associated with loops/blocks they label). Name conflicts with variables are generally not an issue as they are in different "namespaces" for the parser.
    -   **Unused Labels:** Go compiler checks this. GoScript would rely on this check.

### Blank identifier

-   **Go Specification:**
    -   Represented by `_`.
    -   Anonymous placeholder.
    -   Special meaning in declarations, as an operand, and in assignments.
        -   `_ = expr`: Evaluates `expr` for side effects, discards value.
        -   `var _ T`: Reserves space for type `T` but doesn't make it accessible (rarely used).
        -   `_, ok := m[key]`: Ignores the first value.
        -   `import _ "package"`: Imports for side effects (e.g., `init` functions).

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   `_ = expr` -> `expr;` (if `expr` is an expression statement) or `_ = expr;` (if `expr` must be in an assignment context, though often the `_ =` can be elided if the expression is used for side-effects only). `compiler.WriteStmtAssign` handles assignments.
        -   `var _ T` -> No direct equivalent or need in TypeScript.
        -   `_, ok := m[key]` -> `let [, ok] = m.getWithOk(key);`. TypeScript's destructuring assignment handles ignoring elements.
        -   `import _ "package"` -> `import "module-name-for-package";`. TypeScript/JavaScript module imports execute the module code upon first import, achieving side effects. `compiler.WriteImportSpec` handles this.
    -   **Divergence:** Generally maps well. TypeScript's `_` can be a normal identifier, but by convention, it's often used for unused parameters/variables. The Go compiler enforces the "true ignore" semantics of `_`.

### Predeclared identifiers

-   **Go Specification:**
    -   Implicitly declared in the universe block.
    -   **Types:** `any`, `bool`, `byte`, `comparable`, `complex64`, `complex128`, `error`, `float32`, `float64`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `string`, `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `uintptr`.
    -   **Constants:** `true`, `false`, `iota`.
    -   **Zero value:** `nil`.
    -   **Functions:** `append`, `cap`, `clear`, `close`, `complex`, `copy`, `delete`, `imag`, `len`, `make`, `max`, `min`, `new`, `panic`, `print`, `println`, `real`, `recover`.

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   **Types:**
            -   `bool` -> `boolean`.
            -   `string` -> `string`.
            -   Numeric types (`int`, `float32`, etc.) -> `number` or `bigint` (for `int64`, `uint64` if values exceed `number` precision). `compiler.WriteBasicType`, `compiler.WriteGoType`.
            -   `byte` (alias for `uint8`) -> `number`.
            -   `rune` (alias for `int32`) -> `number`.
            -   `uintptr` -> `number` or `bigint`. Its meaning is platform-dependent and less direct in TS.
            -   `error` -> `gs.Error` (custom interface/class in `@goscript/builtin`, typically `interface Error { error: string }` or similar to `Error` built-in).
            -   `complex64`, `complex128` -> `gs.Complex` (custom class in `@goscript/builtin`).
            -   `any` (Go 1.18+, alias for `interface{}`) -> `any` in TypeScript.
            -   `comparable` (Go 1.18+, interface constraint) -> No direct single keyword. Used in generic constraints. TypeScript's `==`, `!=` work on many types. For struct/array comparison, GoScript needs custom logic (e.g., `gs.equals`).
        -   **Constants:**
            -   `true`, `false` -> `true`, `false`.
            -   `iota` -> Handled by `compiler.WriteValueSpec` during constant generation. Not a runtime value.
        -   **Zero value:**
            -   `nil` -> `null` generally. For specific Go types that can be `nil` (pointers, slices, maps, channels, interfaces, functions), their TS counterparts must be nullable.
        -   **Functions:** These are built-in functions in Go.
            -   Mapped to functions/methods in `@goscript/builtin`. E.g., `len(s)` -> `s.length` (for strings/arrays) or `s.len()` (for `gs.Slice`, `gs.Map`), `append(sl, ...)` -> `gs.append(sl, ...)`, `make(...)` -> `gs.makeSlice()`, `gs.makeMap()`, `gs.makeChannel()`, `new(T)` -> `gs.new(T_constructor)` or `new T_ts()`, `panic(v)` -> `gs.panic(v)`, `recover()` -> `gs.recover()`, `print`, `println` -> `console.log` or `gs.print/println`.
            -   `clear` (Go 1.21+ for maps, slices) -> `map.clear()`, `slice.clear()` (or equivalent operations).
            -   `max`, `min` (Go 1.21+ for ordered types) -> `Math.max`, `Math.min` or custom `gs.max/min` for broader type support.
    -   **Divergence:** The primary "divergence" is that these are not globally available keywords/functions in TS but are provided via the `gs` runtime module or direct TS equivalents. The GoScript compiler must ensure correct translation (e.g., `len(x)` to `x.length` or `gs.len(x)` depending on `x`'s type).

### Exported identifiers

-   **Go Specification:**
    -   An identifier is exported if:
        1.  First character is a Unicode uppercase letter.
        2.  Declared in package block OR is a field name or method name.
    -   All other identifiers are not exported (package-private).

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   **Top-level (package block):**
            -   Exported Go identifier (e.g., `Var`, `Func`, `Type`) -> TypeScript `export const Var ...`, `export function Func ...`, `export class/type Type ...`. Handled by `compiler.WriteDecls`, etc.
            -   Unexported Go identifier (e.g., `myVar`) -> TypeScript `const myVar ...` (not exported from the module).
        -   **Struct Fields:**
            -   Exported Go field (`FieldName`) -> TypeScript public field `FieldName` (default).
            -   Unexported Go field (`fieldName`) -> TypeScript public field `fieldName`. TypeScript's `private` keyword creates fields that are only accessible within the class, which is stricter than Go's package-level unexported.
            -   **Divergence:** Go's package-level privacy for unexported struct fields is not directly replicable. In TS, all fields of a class are accessible if the class instance is accessible, unless marked `private` (class-private) or `protected` (class and subclass private). GoScript currently generates all fields as public TS fields. True package-level privacy would require more complex schemes (e.g. Symbol-keyed properties or closures if trying to emulate, but this is generally not idiomatic TS).
        -   **Method Names:**
            -   Exported Go method (`MethodName`) -> TypeScript public method `MethodName`.
            -   Unexported Go method (`methodName`) -> TypeScript public method `methodName`.
            -   **Divergence:** Same as struct fields regarding package-level privacy. TypeScript `private` methods are class-private.
    -   **Module System:** Go's package system vs. ES Modules. GoScript generates ES Modules. Access across modules relies on `export` and `import`.

### Uniqueness of identifiers

-   **Go Specification:**
    -   An identifier is unique in a set if different from every other.
    -   Different if spelled differently OR in different packages and not exported. Otherwise, they are the same.
    -   (This means unexported identifiers from different packages are distinct even if spelled the same).

-   **GoScript & Divergences:**
    -   **TypeScript Scope:** TypeScript identifiers are unique based on their spelling and scope (block, function, module).
    -   **Unexported from Different Packages:**
        -   Go: `packageA.myType` (unexported `type myType struct{ val int }`) and `packageB.myType` (unexported `type myType struct{ name string }`) are distinct.
        -   GoScript: If these are translated to `class myType` within their respective modules (`moduleA.ts`, `moduleB.ts`), then `moduleA.myType` and `moduleB.myType` (if they were exported for some reason, or used internally) would be distinct types in TypeScript. If they are not exported, they are local to their modules.
        -   **Divergence:** This aspect generally aligns if Go packages map to TS modules. The main concern is if GoScript needs to mangle names of unexported types/fields from different packages to avoid accidental structural compatibility if they happen to have the same structure and field names. However, since they are unexported, direct conflict is less likely unless through type assertions or interfaces involving them.

### Constant declarations

-   **Go Specification:**
    -   `const ( id1 = expr1; id2 = expr2 )` or `const id = expr`.
    -   Binds identifiers to values of constant expressions.
    -   Number of identifiers must equal number of expressions.
    -   Typed constants: `const Pi float64 = 3.14`. Expressions must be assignable to the type.
    -   Untyped constants: `const zero = 0.0`. Constants take type of expression. If expr is untyped, const remains untyped.
    -   Implicit repetition: In a `const (...)` block, an empty expression list repeats the previous non-empty list and its type.
        ```go
        const (
            a = 1
            b // b = 1
            c = "foo"
            d // d = "foo"
        )
        ```

-   **GoScript & Divergences:**
    -   **Mapping:** `compiler.WriteDecls` and `compiler.WriteValueSpec` handle `const` declarations.
        -   Go `const NAME Type = value` -> TS `export const NAME: TsType = tsValue;` (if exported) or `const NAME: TsType = tsValue;`.
        -   Go `const NAME = untypedValue` -> The Go type checker resolves the type of `NAME` in its context. GoScript translates it with this resolved type. E.g., `const x = 0` used as an `int` becomes `const x: number = 0`.
    -   **Untyped Constants in Go vs. Typed Literals in TS:**
        -   Go's untyped constants have high precision and adapt to context.
        -   TypeScript literals have types (e.g., `0` is `number`, `"foo"` is `string`).
        -   **Divergence:** The flexibility of Go's untyped constants is handled by the Go compiler frontend. GoScript receives information about the constant *after* its type has been determined for its usage or default type. The generated TS code will use typed constants.
    -   **Implicit Repetition:**
        -   This Go feature (empty expression list repeating the previous) needs to be explicitly handled by GoScript. The Go parser provides the AST with resolved values for such constants. GoScript's `compiler.WriteValueSpec` should receive the final values.
    -   **`iota`:** Discussed next.

### Iota

-   **Go Specification:**
    -   Used within a `const` declaration. Represents successive untyped integer constants.
    -   Value is the index of the `ConstSpec` in the declaration (0-indexed).
    -   Resets to 0 for each new `const` block.
    -   Example: `const (c0 = iota; c1; c2)` -> `c0=0, c1=1, c2=2`.

-   **GoScript & Divergences:**
    -   **Compile-time Evaluation:** `iota` is a Go compile-time mechanism. The Go parser and type-checker resolve the actual values of constants declared using `iota`.
    -   **GoScript:** `compiler.WriteValueSpec` receives the final numeric value for constants defined with `iota`. It does not "re-evaluate" `iota`.
    -   **Divergence:** No divergence in behavior, as GoScript translates the *result* of `iota` expansion, not `iota` itself. The generated TypeScript code will contain the literal numeric values.
        ```go
        // Go
        const (
            Read = 1 << iota // 1
            Write            // 2
            Execute          // 4
        )
        // GoScript Output (conceptual)
        export const Read: number = 1
        export const Write: number = 2
        export const Execute: number = 4
        ```
    -   This mapping is straightforward.

### Type declarations

Go has two forms of type declarations: alias declarations and type definitions.

#### Alias declarations

-   **Go Specification (Go 1.9+):**
    -   `type IdentifierList = Type`
    -   Binds an identifier (or list of identifiers) to a given type. The identifier becomes an alias for the type.
    -   The alias and the original type are identical. They can be used interchangeably.
    -   Example: `type nodeList = []*Node` means `nodeList` and `[]*Node` are the same type.
    -   Example: `type Polar = polar` means `Polar` and `polar` are the same type.
    -   Generic aliases (Go 1.24+): `type set[P comparable] = map[P]bool`. Must be instantiated.
    -   The aliased type cannot be a type parameter itself (e.g., `type A[P any] = P` is illegal).

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   `type MyAlias = ExistingType` -> `type MyAlias = ExistingType;` (using TypeScript's type alias).
        -   `compiler.WriteTypeSpec` handles `ast.TypeSpec` which includes alias declarations (`spec.Assign > 0`).
    -   **Identical Types:** TypeScript's type aliases also create names that are interchangeable with the original type, fitting Go's semantics well.
        ```typescript
        // Go: type MyInt = int
        // TS: type MyInt = number;
        let x: MyInt = 10;
        let y: number = x; // OK
        x = y; // OK
        ```
    -   **Generic Aliases:**
        -   Go: `type MyMap[K comparable, V any] = map[K]V`
        -   TS: `type MyMap<K extends string | number | symbol, V> = Map<K, V>;` (or `gs.Map<K,V>`)
        -   This maps well to TypeScript's generic type aliases.
    -   **Restriction on aliasing type parameters:**
        -   Go: `type A[P any] = P // illegal`
        -   TS: `type A<P> = P; // legal`
        -   **Divergence (Minor):** TypeScript allows aliasing a type parameter. GoScript would rely on the Go compiler to disallow this, so it wouldn't encounter such valid Go code that is invalid in Go.
    -   **Overall:** Alias declarations map very well to TypeScript type aliases.

#### Type definitions

-   **Go Specification:**
    -   `type IdentifierList Type`
    -   Creates a **new, distinct type**.
    -   This new type has the same underlying type and operations as the given type.
    -   The new type is called a "defined type". It is different from any other type, including the one it's created from.
    -   Example: `type Point struct{ x, y float64 }`. `Point` is distinct from `struct{ x, y float64 }`.
    -   Example: `type MyInt int`. `MyInt` is distinct from `int`.
    -   **Methods:**
        -   A defined type can have methods associated with it.
        -   It does **not** inherit methods from the original type.
        -   E.g., `type NewMutex Mutex`. If `Mutex` has methods, `NewMutex` does not inherit them.
        -   However, the method set of an interface type or of elements of a composite type remains unchanged.
            -   `type MyBlock Block` (if `Block` is an interface) -> `MyBlock` has the same method set as `Block`.
            -   `type MyStructSlice []MyStruct` -> elements are `MyStruct`.
    -   **Generic Types:**
        -   `type List[T any] struct { ... }`. `List` is a generic type. Must be instantiated.
        -   Methods on generic types must declare the same number of type parameters.
    -   The defined type cannot be a type parameter itself (e.g., `type T[P any] P` is illegal).

-   **GoScript & Divergences:**
    -   **Mapping Defined Types (Nominal Typing):**
        -   Go: `type MyInt int`
        -   TypeScript is structurally typed. To achieve nominal typing (distinct types), various patterns are used:
            1.  **Branding/Tagging:**
                ```typescript
                type MyInt = number & { __brand: "MyInt" };
                function NewMyInt(val: number): MyInt { return val as MyInt; }
                let a: MyInt = NewMyInt(5);
                let b: number = 10;
                // a = b; // Error: Type 'number' is not assignable to type 'MyInt'.
                // b = a; // OK, MyInt is a subtype of number
                ```
            2.  **Classes:**
                ```typescript
                class MyInt {
                    constructor(public value: number) {}
                    // Potentially add methods specific to MyInt
                }
                let a = new MyInt(5);
                let b: number = 10;
                // a = b; // Error
                // b = a.value; // OK
                ```
        -   **GoScript Choice:** GoScript uses classes to represent defined types to achieve nominal typing and to associate methods. `compiler.WriteTypeSpec` for `TypeDef`s (where `spec.Assign == 0`) typically generates a class.
        -   `type MyInt int` -> `class MyInt extends gs.NumberVarRef<MyInt> { ... }` or similar, to allow methods and distinctness. For simple types like `int`, it might use a branded type if no methods are expected and varRefing is undesirable. However, for consistency and method attachment, classes are more robust. The `DESIGN.md` mentions nominal typing for defined types.
    -   **Method Inheritance:**
        -   Go: Defined types do not inherit methods. `type NewMutex Mutex` -> `NewMutex` has no methods of `Mutex`.
        -   GoScript: If `Mutex` is `class Mutex { lock() {} }` and GoScript generates `class NewMutex extends Mutex {}`, then `NewMutex` *would* inherit methods in TS. This is a **divergence**.
        -   To correctly model Go's behavior, `NewMutex` should not extend `Mutex`. If `NewMutex` is `type NewMutex Mutex`, it means `NewMutex` has the *structure* of `Mutex` but is a distinct type.
            -   If `Mutex` is `struct { field int }`, then `NewMutex` is `class NewMutex { field: number }`.
            -   If `Mutex` is `MyBaseType`, then `NewMutex` is `class NewMutex { /* fields of MyBaseType */ }`.
        -   **GoScript Implementation:** `compiler.WriteTypeSpec` for a `TypeDef` like `type T1 T2` generates a new class `T1` that has the same structure as `T2` but does not inherit `T2`'s methods directly through TS inheritance if `T2` is also a class. It would copy the structure.
    -   **Interface Type Definitions:**
        -   Go: `type MyBlock Block` (where `Block` is an interface). `MyBlock` has the same method set.
        -   TS: `interface Block { m(): void; } type MyBlock = Block;`
        -   This maps well. If `MyBlock` is a defined type `type MyBlock Block`, then in TS it would be `interface MyBlock extends Block {}` but with a brand or treated as a distinct interface type that happens to have the same methods. GoScript typically generates `interface MyBlock extends OriginalInterface {}` and relies on structural compatibility for assignment, but for *defined* interface types, it should ensure distinctness if methods are added to `MyBlock` but not `Block`.
    -   **Generic Type Definitions:**
        -   Go: `type List[T any] struct { val T; next *List[T]; }`
        -   TS: `class List<T> { val: T; next: List<T> | null; constructor(...) }`
        -   This maps well to TypeScript generic classes. `compiler.WriteTypeSpec` handles this.
    -   **Methods on Generic Types:**
        -   Go: `func (r *List[T]) Add(val T) {}`
        -   TS: `class List<T> { add(val: T): void {} }`
        -   This also maps well.
    -   **Restriction on defining over type parameters:**
        -   Go: `type T[P any] P // illegal for type definition`
        -   TS: `class T<P> { constructor(public value: P) {} } // legal, but different meaning`
        -   **Divergence (Minor):** Similar to alias declarations, TypeScript is more permissive. GoScript relies on the Go compiler for this check.
    -   **Key Divergence:** Achieving true nominal typing for defined types (especially for basic types like `type MyInt int`) and correctly handling the "no method inheritance" rule for type definitions requires careful code generation, typically using classes and avoiding direct TS `extends` if the Go source was `type T1 T2` (not embedding). GoScript's use of classes for defined types is the chosen strategy.

### Type parameter declarations

-   **Go Specification (Go 1.18+):**
    -   Defines type parameters for generic functions or types, e.g., `[P any]`, `[S ~[]E, E any]`, `[S interface{ ~[]byte|string }]`.
    -   The list is enclosed in square brackets `[]`. Parameter names must be present and unique.
    -   Each type parameter acts as a placeholder for an unknown type, replaced by a type argument upon instantiation.
    -   A parsing ambiguity can occur if a constraint makes the declaration look like an array type (e.g., `type T[P *C]`). This is resolved by embedding the constraint in an interface (e.g., `type T[P interface{*C}]`) or using a trailing comma (e.g., `type T[P *C,]`).
    -   Within a type parameter list of a generic type `T`, a type constraint cannot directly or indirectly refer to `T` (e.g., `type T1[P T1[P]]` is illegal).

-   **GoScript & Divergences:**
    -   **Mapping:** Go generic type parameters map to TypeScript generic parameters.
        -   Go: `func F[T any](p T){}` -> TS: `function F<T>(p: T): void {}` (or `T = any` if no constraint).
        -   Go: `type L[T any] struct{}` -> TS: `class L<T> {}`.
        -   The `compiler` package functions like `WriteFuncDeclAsFunction`, `WriteFuncDeclAsMethod`, and `WriteTypeSpec` handle `ast.FieldList` for type parameters to generate TypeScript generics.
    -   **Parsing Ambiguity:** This is a Go parser-level issue. GoScript consumes an already parsed AST, so the Go toolchain would have resolved such ambiguities.
    -   **Self-referential Constraints:** The Go compiler disallows these. GoScript would not encounter valid Go code with this structure.
    -   **Overall:** Go type parameters generally map well to TypeScript generic parameters. The core complexity lies in accurately translating the constraints.

### Type constraints

-   **Go Specification (Go 1.18+):**
    -   A type constraint is an interface that defines the set of permissible type arguments for a type parameter and controls the operations supported by values of that type parameter.
    -   Syntax: `TypeConstraint = TypeElem`.
    -   Shorthand in type parameter lists:
        -   `[T []P]` is equivalent to `[T interface{[]P}]`.
        -   `[T ~int]` is equivalent to `[T interface{~int}]`.
        -   `[T int|string]` is equivalent to `[T interface{int|string}]`.
        -   This shorthand (omitting `interface{...}`) is only valid in type parameter lists.
    -   **Type Elements in Constraints:**
        -   `~T`: Represents the type `T` itself or any type whose underlying type is `T`.
        -   `T1 | T2`: Represents the union of types `T1` and `T2`.
    -   **Predeclared `comparable` interface:**
        -   Denotes the set of all non-interface types that are strictly comparable (i.e., can be compared using `==` and `!=`).
        -   `comparable` and interfaces that embed `comparable` (e.g., `interface{ comparable; M() }`) can only be used as type constraints. They cannot be the type of a variable or value.

-   **GoScript & Divergences:**
    -   **Mapping Constraints to TypeScript `extends`:**
        -   `any` (as constraint): `T any` -> `<T = any>` or `<T = unknown>`.
        -   Specific interface: `T MyInterface` -> `<T extends MyInterfaceTS>`.
        -   Union: `T int|string` -> `<T extends number | string>`.
        -   `~T` (underlying type constraint):
            -   Go: `type MyInt int; func F[T ~MyInt](p T){}` allows `F` to be called with `MyInt` or `int`.
            -   TS: If `MyInt` is `type MyInt = number & { __brand: "MyInt" };`, then `~MyInt` could map to `<T extends number>`. If `MyInt` is `class MyInt { value: number }`, a constraint like `<T extends number | MyInt>` might be needed.
            -   **Divergence (Minor/Moderate):** Mapping `~T` precisely can be complex, especially for defined types emulating nominal typing. For basic types like `~int`, it's simpler (`<T extends number>`). GoScript needs to resolve the underlying type for the constraint.
        -   `comparable` constraint:
            -   Go: `[T comparable]`
            -   TS: TypeScript has no direct `comparable` keyword. This can be mapped to a union of comparable primitive types (`<T extends string | number | boolean | symbol | bigint | null | undefined>`) or a specific utility type in `@goscript/builtin` (e.g., `gs.Comparable`). Operations like `==` on `T` would then likely use `gs.equals(a,b)` to emulate Go's behavior.
            -   **Divergence (Moderate):** The `comparable` constraint requires a dedicated translation strategy to ensure correct operational semantics, potentially relying on runtime helpers.
    -   **`comparable` as a non-constraint type:** Go disallows `var x comparable;`. TypeScript doesn't have `comparable` as a standalone type, so this restriction aligns naturally.
    -   The `compiler.writeTypeDescription` function is responsible for translating these constraint interfaces.

### Satisfying a type constraint

-   **Go Specification (Go 1.18+):**
    -   A type argument `A` *satisfies* a constraint `C` if `A` is an element of the type set defined by `C` (i.e., `A` implements `C`).
    -   **Exception for `comparable` (Go 1.20+):**
        -   A constraint `C` that requires strict comparability (e.g., `comparable` itself, or `interface{ comparable; E }` where `E` is a basic interface) can also be satisfied by a type argument `A` that is comparable but not necessarily *strictly* comparable (e.g., an interface type), provided `A` also implements `E`.
        -   Examples:
            -   `any` (which is an interface type) satisfies `comparable`.
            -   `interface{ m() }` satisfies `interface{ comparable; m() }`.
        -   **Implication:** An operation like `==` or `!=` on a value of a type parameter constrained by `comparable` may panic at runtime if the actual type argument provided at instantiation is an interface type (as interface comparison itself can panic if dynamic types are not comparable).

-   **GoScript & Divergences:**
    -   **TypeScript `extends`:** TypeScript's `extends` keyword in generics (`<T extends C>`) enforces that type arguments are assignable to the constraint `C`.
    -   **`comparable` Exception & Runtime Behavior:**
        -   Go: `func IsEqual[T comparable](a, b T) bool { return a == b }`. If `IsEqual` is called with an interface type for `T`, `a == b` might panic.
        -   TS: If `T` is loosely translated from `comparable` to `any` or `unknown`, `a == b` in TypeScript performs reference comparison for objects or value comparison for primitives. This differs from Go's interface comparison semantics.
        -   **Divergence (Moderate/Major):** The potential runtime panic for `comparable` type parameters when using `==` with interface type arguments is a significant Go-specific behavior. To emulate this, GoScript must translate `a == b` (where `a` or `b` are of a type parameter constrained by `comparable`) to a runtime helper like `gs.equals(a, b)`. This helper would need to replicate Go's comparison logic, including the panic behavior for incomparable dynamic types within interfaces.
        -   If a type parameter is constrained by `comparable`, GoScript should ensure that comparisons use a runtime helper that mimics Go's behavior, rather than relying on TypeScript's native `==`/`!=` which have different semantics for non-primitive types.
    -   **Overall:** While TypeScript's `extends` handles basic constraint satisfaction, the special rules and runtime behaviors associated with Go's `comparable` constraint (especially its interaction with interface types) require careful translation and likely runtime support in `@goscript/builtin`.

### Variable declarations

-   **Go Specification:**
    -   `var IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList )`
    -   Creates variables, binds identifiers, gives type and initial value.
    -   If expressions are given, variables are initialized as per assignment rules.
    -   Otherwise, initialized to zero value.
    -   If type is present, variables get that type.
    -   Otherwise, type is inferred from initialization value.
        -   Untyped constant -> default type (e.g., `42` -> `int`).
        -   Untyped boolean -> `bool`.
        -   `nil` cannot initialize a variable without explicit type.
    -   Compiler may disallow unused variables in function bodies.

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   `var i int` -> `let i: number = 0;`
        -   `var k = 0` -> `let k: number = 0;` (type inferred by Go, then translated)
        -   `var x, y float32 = -1, -2` -> `let x: number = -1; let y: number = -2;`
        -   `compiler.WriteDecls` and `compiler.WriteValueSpec` handle `var` declarations.
    -   **Type Inference:** Go's type inference for `var k = 0` (to `int`) is handled by the Go frontend. GoScript receives the typed AST.
    -   **Zero Values:** GoScript's `WriteZeroValueForType` generates appropriate zero values for TypeScript (e.g., `0` for `number`, `null` for objects/pointers, `false` for `boolean`, `""` for `string`).
    -   **`nil` without type:** `var n = nil;` is illegal in Go. GoScript would rely on the Go compiler to catch this.
    -   **Unused Variables:** TypeScript compilers/linters also typically warn about unused variables.
    -   **Divergence:** Generally maps well. TypeScript's `let` (and `const` for constants) are the equivalents.

### Short variable declarations

-   **Go Specification:**
    -   `IdentifierList := ExpressionList`
    -   Shorthand for `var IdentifierList = ExpressionList`. Types are inferred.
    -   May redeclare variables in the same block (or function parameters) if:
        1.  They were originally declared earlier in the same block.
        2.  They are redeclared with the same type.
        3.  At least one non-blank variable on the left is new.
    -   Redeclaration assigns a new value, doesn't create a new variable.
    -   Non-blank variable names on the left must be unique.
    -   Only allowed inside functions (including `if`/`for`/`switch` initializers).

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   `i, j := 0, 10` -> `let i: number = 0; let j: number = 10;`
        -   `compiler.WriteStmtAssign` handles `token.DEFINE` (short variable declaration).
    -   **Redeclaration:**
        -   Go:
            ```go
            x := 10
            x, y := 20, 30 // x is redeclared, y is new
            ```
        -   TypeScript: `let` does not allow redeclaration in the same scope.
            ```typescript
            let x = 10;
            // let x = 20, y = 30; // Error: Cannot redeclare block-scoped variable 'x'.
            x = 20; let y = 30; // This is the equivalent assignment
            ```
        -   **Divergence (Moderate):** Go's `:=` redeclaration semantics are unique. GoScript's `compiler.WriteStmtAssign` must handle this by:
            -   Identifying which variables are new and which are being reassigned.
            -   Emitting `let` for new variables.
            -   Emitting simple assignment for existing variables.
            -   The Go `types.Info.Defs` and `Uses` maps help distinguish new variables from assignments to existing ones.
    -   **Scope:** `:=` is function-scoped in Go. `let` is block-scoped in TypeScript. This usually aligns because `:=` often appears at the beginning of blocks or in contexts that form implicit blocks.
    -   **Uniqueness on Left:** Go: `x, y, x := 1,2,3` is illegal. TypeScript would also disallow `let x,y,x = ...`.
    -   **Overall:** The main challenge is correctly implementing the redeclaration aspect of `:=`.

### Function declarations

-   **Go Specification:**
    -   `func FunctionName [ TypeParameters ] Signature [ FunctionBody ]`
    -   Binds function name to a function.
    -   If signature declares results, body must end with a terminating statement (e.g., `return`).
    -   Generic functions (with `TypeParameters`) must be instantiated before use.
    -   Body can be omitted for functions implemented externally (e.g., assembly).

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   `func MyFunc(p int) string { ... }` -> `function MyFunc(p: number): string { ... }`
        -   `compiler.WriteFuncDeclAsFunction` handles this.
    -   **Terminating Statement:** TypeScript has similar rules for functions with declared return types (though `void` functions don't strictly need a `return`). The Go compiler enforces this.
    -   **Generic Functions:**
        -   Go: `func min[T ~int|~float64](x, y T) T { ... }`
        -   TS: `function min<T extends number>(x: T, y: T): T { ... }`
        -   Instantiation in Go is often implicit. In TypeScript, generic functions are called with type arguments inferred or explicitly provided. This maps well.
    -   **External Functions:**
        -   Go: `func flushICache(begin, end uintptr)`
        -   TS: `declare function flushICache(begin: number, end: number): void;` (using an ambient declaration).
        -   **Divergence (Minor):** GoScript would need a mechanism to identify these (e.g., no function body in AST) and generate `declare function` or link to provided external implementations.
    -   **Overall:** Function declarations map well to TypeScript functions.

### Method declarations

-   **Go Specification:**
    -   `func Receiver MethodName Signature [ FunctionBody ]`
    -   A function with a receiver. Associates method with receiver's base type.
    -   Receiver: `(ident T)` or `(ident *T)`. `T` must be a defined type (or pointer to defined type) in the same package.
    -   `T` cannot be a pointer or interface type itself.
    -   If receiver has type parameters (for generic types): `(ident T[P1, P2, ...])`.
    -   Method name visible only via selectors on `T` or `*T`.

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   Go: `func (p *Point) Length() float64 { ... }`
        -   TS: If `Point` is `class Point { ... }`, then `class Point { Length(): number { ... } }`.
        -   `compiler.WriteFuncDeclAsMethod` handles this.
    -   **Receiver Base Type:**
        -   Go requires `T` to be a defined type in the same package. TypeScript methods are part of class definitions, naturally associating them.
        -   Go: `T` cannot be a pointer or interface.
        -   TS: Methods are on classes/objects, not directly on type aliases for pointers or interfaces (though interfaces can specify method signatures).
    -   **Value vs. Pointer Receivers:**
        -   Go: `func (p Point) Scale(f float64)` (value receiver, operates on copy).
        -   Go: `func (p *Point) Translate(dx, dy float64)` (pointer receiver, operates on original).
        -   TS: Class methods always operate on the instance (`this`).
        -   **Divergence (Major):** This is a core Go semantic. GoScript must emulate value/pointer receiver behavior.
            -   For **pointer receivers** (`*T`), methods modify `this`. This maps naturally.
            -   For **value receivers** (`T`), the method should operate on a *copy* of `this` and, if it "returns" a modified `T`, it must actually return a new instance. Go methods with value receivers that modify fields don't actually change the original variable unless the result is reassigned.
            -   `DESIGN.md` discusses this: pointer receivers are straightforward. Value receivers are more complex. If a value receiver method modifies the struct, GoScript might need to make such methods return `this.clone()._update_fields(...)` and require call sites to use the returned value if modifications are intended to persist. Or, if modifications are purely internal to the method call and the original should not change, the method operates on `this.clone()`.
    -   **Methods on Generic Types:**
        -   Go: `func (l *List[T]) Add(val T) { ... }`
        -   TS: `class List<T> { Add(val: T): void { ... } }`
        -   This maps well. The receiver type parameters must match the class's type parameters.
    -   **Overall:** Method declarations map to class methods in TypeScript. The most significant challenge is accurately representing the semantics of value vs. pointer receivers, particularly for mutations.

### Method declarations (Continued)

-   **Go Specification (Continued):**
    -   **Receiver Type Parameters for Generic Types:**
        -   When a method is declared on a generic type, the receiver specification must declare corresponding type parameters for the method to use.
        -   Example: `type Pair[A, B any] struct { ... }; func (p Pair[T1, T2]) Swap() Pair[T2, T1] { ... }`. Here, `T1, T2` are declared for the method, corresponding to `A, B` of `Pair`.
        -   The names of these type parameters do not need to match the original type's parameter names. Constraints are implied from the base type.
    -   **Restrictions on Aliases as Receiver Types:**
        -   If the receiver base type is an alias, that alias must not be generic itself and must not denote an instantiated generic type (directly or indirectly).
        -   Example: `type GPoint[P any] = Point; func (*GPoint[P]) Draw() {}` is illegal.
        -   Example: `type HPoint = *GPoint[int]; func (HPoint) Draw() {}` is illegal.

-   **GoScript & Divergences (Continued):**
    -   **Receiver Type Parameters:**
        -   This maps well to TypeScript methods on generic classes.
        -   Go: `func (p Pair[A, B]) Swap() Pair[B, A]`
        -   TS: `class Pair<A, B> { Swap(this: Pair<A,B>): Pair<B,A> { ... } }` (TypeScript implicitly makes `A` and `B` available from the class scope).
        -   The `compiler.WriteFuncDeclAsMethod` ensures that the method signature correctly uses the generic parameters of the class it's attached to.
    -   **Aliases as Receiver Types:**
        -   These are Go compiler restrictions. GoScript processes valid Go AST, so it would not encounter these illegal forms. This means no direct divergence in GoScript's translation logic itself, as the input Go code would already be valid.

## Expressions

### Operands

-   **Go Specification:**
    -   Operands are elementary values: literals, identifiers (constants, variables, functions), or parenthesized expressions.
    -   Syntax: `Operand = Literal | OperandName [ TypeArgs ] | "(" Expression ")"`.
    -   `OperandName` can be `identifier` or `QualifiedIdent`.
    -   An operand name denoting a generic function can be followed by `TypeArgs` for instantiation.
    -   Blank identifier `_` only on LHS of assignment.
    -   Implementation restriction: Compiler might not error for type parameter with empty type set until instantiation.

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   Literals: Handled by `compiler.WriteBasicLit`, `compiler.WriteCompositeLit`, `compiler.WriteFuncLitValue`. Generally map well to TS equivalents.
        -   Identifiers: `compiler.WriteIdent` translates Go identifiers.
        -   Generic Function Instantiation: `min[int](a,b)` -> `min<number>(a,b)`. Handled by `compiler.WriteCallExpr` when an instantiated generic function is called.
        -   Parenthesized expressions: `(a + b)` -> `(a + b)`. Standard.
    -   **Blank Identifier:** Go compiler enforces its usage. GoScript translates assignments involving `_` by typically omitting the variable on the TS side if it's truly unused or assigning to a temporary placeholder if the expression has side effects.
    -   **Empty Type Set for Type Parameter:** This is a Go compiler concern related to generic function instantiation. GoScript would process the AST assuming valid Go generics.
    -   **Overall:** Operands map fairly directly.

### Qualified identifiers

-   **Go Specification:**
    -   `QualifiedIdent = PackageName "." identifier`.
    -   Accesses an exported identifier from an imported package.
    -   Identifier must be declared in the package block of that package.

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   Go: `math.Sin`
        -   TS: `import * as math from "math_module_path"; math.Sin` or `import { Sin } from "math_module_path"; Sin`.
        -   GoScript uses `compiler.WriteSelectorExpr` for `pkg.Ident` expressions.
        -   Import generation is handled by `compiler.CodeWriter.WriteImport`, and module path resolution by `output.ComputeModulePath` and `output.TranslateGoFilePathToTypescriptFilePath`.
    -   **Divergence (Minor):** TypeScript's module system is different (ES modules vs. Go packages), but the concept of importing and qualifying names is analogous. GoScript aims to create idiomatic TS imports.

### Composite literals

-   **Go Specification:**
    -   Construct values for structs, arrays, slices, maps: `LiteralType LiteralValue`.
    -   `LiteralType` can be `StructType`, `ArrayType`, `SliceType`, `MapType`, or `TypeName [ TypeArgs ]`.
    -   `LiteralValue` is `{ [ ElementList [ "," ] ] }`.
    -   Elements can be `[ Key ":" ] Element`.
        -   Key: field name (structs), index (arrays/slices), key (maps).
    -   Underlying type of `LiteralType` must be struct, array, slice, or map (unless `LiteralType` is a type parameter, in which case all types in its set must have the same underlying composite type).
    -   Types of elements/keys must be assignable.
    -   For map literals, all elements must have a key.
    -   Duplicate keys (field names or constant map keys) are an error.
    -   If `LiteralType` is a type parameter, it must be instantiated.

-   **GoScript & Divergences:**
    -   Handled by `compiler.WriteCompositeLit`.
    -   **Struct Literals:**
        -   Go: `Point{X: 1, Y: 2}` or `Point{1, 2}` (if field order is known).
        -   TS: `Point.new({X: 1, Y: 2})` or `new Point({X: 1, Y: 2})` (typically using an object for initialization, as per `DESIGN.md`). GoScript generates keyed elements.
    -   **Array Literals:**
        -   Go: `[3]int{1, 2, 3}` or `[...]int{1, 2, 3}`.
        -   TS: `gs.NewArray(3, gs.Int, [1, 2, 3])`. Fixed-size arrays often require runtime helpers. Omitted values are zero-initialized in Go (e.g., `[3]int{1}` is `[1,0,0]`). GoScript's `WriteCompositeLit` must ensure this padding with zero values.
    -   **Slice Literals:**
        -   Go: `[]int{1, 2, 3}`.
        -   TS: `gs.NewSlice(gs.Int, [1, 2, 3])` or directly `[1, 2, 3]` if the target type is `gs.Slice<number>`. Runtime helpers are common.
    -   **Map Literals:**
        -   Go: `map[string]int{"a": 1, "b": 2}`.
        -   TS: `gs.NewMap<string, number>([["a", 1], ["b", 2]])`. Runtime helper `gs.NewMap` is used.
    -   **LiteralType as Type Parameter:** Advanced generics. Go: `func makePair[T1, T2 any](a T1, b T2) Pair[T1, T2] { return Pair[T1,T2]{a, b} }`. GoScript translates the instantiated form.
    -   **Divergences (Minor to Moderate):**
        -   **Structs:** Go's implicit field order for unkeyed literals is not directly available in TS object literals; GoScript relies on keyed elements.
        -   **Arrays:** TypeScript lacks true fixed-size arrays distinct from dynamic arrays in the same way Go does. GoScript uses runtime helpers (`gs.Array`) to emulate Go's array semantics (fixed size, distinct type from slice).
        -   **Zero-value padding:** For array literals like `[5]int{1,2}`, GoScript must explicitly pad with `0,0,0`.
        -   **Instantiation:** GoScript generally uses runtime helper functions (`gs.NewArray`, `gs.NewSlice`, `gs.NewMap`) or static `new` methods on generated classes for composite literals to ensure correct Go semantics (e.g., cloning, type information).

### Composite literals (Continued)

-   **Go Specification (Continued):**
    -   **Struct Literal Rules:**
        -   Key must be a declared field name.
        -   No keys: elements must be in declared field order.
        -   Any key: all elements must have keys.
        -   Keyed list: omitted fields get zero value.
        -   Empty element list `{}`: evaluates to zero value for the struct type.
        -   Error to specify element for non-exported field of a struct from a different package.
    -   **Array and Slice Literal Rules:**
        -   Elements have integer indices.
        -   Keyed element: key is index (non-negative `int` constant).
        -   Unkeyed element: index is previous index + 1 (or 0 if first).
    -   **Address of Composite Literal:** `&Point3D{y: 1000}` generates a pointer to a unique variable initialized with the literal's value.
        -   Zero value for slice/map (`[]int{}`) is not the same as uninitialized (`new([]int)` which is `nil`). `&[]int{}` points to an initialized, empty slice.
    -   **Array Literal Length:**
        -   Length is from literal type (e.g., `[10]string`).
        -   Missing elements are zero-valued.
        -   `[...]` notation: length is max element index + 1.
    -   **Slice Literal Length/Capacity:** Describes the entire underlying array literal. Length/capacity is max element index + 1. `[]T{x1...xn}` is shorthand for `tmp := [n]T{x1...xn}; tmp[0:n]`.
    -   **Eliding Literal Types in Nested Literals:**
        -   If element/key type is `T`, inner composite literal of type `T` can omit `T`. E.g., `[][]int{{1,2}}` for `[][]int{[]int{1,2}}`.
        -   If element/key type is `*T`, inner `&T{...}` can be written as `{...}`. E.g., `[2]*Point{{1,2}}` for `[2]*Point{&Point{1,2}}`.
    -   **Parsing Ambiguity:** `if x == (T{a,b,c}[i]) { ... }` - literal needs parentheses if it's a `TypeName` form and appears unbracketed before an `if/for/switch` block opening brace.

-   **GoScript & Divergences (Continued):**
    -   **Struct Literal Rules:**
        -   GoScript's `compiler.WriteCompositeLit` translates keyed struct literals to `Point.new({field: value, ...})` or `new Point({field: value, ...})`.
        -   Unkeyed literals: GoScript would need to know field order to map `Point{1,2,3}` to `Point.new({x:1, y:2, z:3})`. This requires struct definition analysis. Current GoScript practice favors keyed literals in output.
        -   Omitted fields: Handled by TypeScript's object initialization (if fields are optional or have defaults) or by the `new` method ensuring zero values.
        -   Zero value `Point3D{}`: `Point3D.new({})` or `new Point3D()`.
        -   Cross-package non-exported fields: Go compiler error.
    -   **Array/Slice Literal Rules (Indices):**
        -   `gs.NewArray` and `gs.NewSlice` helpers take an array of values. Keyed elements like `[5]int{2:10}` (meaning `[0,0,10,0,0]`) require GoScript to construct the full array with zero padding before passing to the helper. E.g., `gs.NewArray(5, gs.Int, [0,0,10,0,0])`.
    -   **Address of Composite Literal:**
        -   Go: `p := &Point{X:1}`. `p` is a pointer.
        -   TS: `let p: Point | null = Point.new({X:1});`. In GoScript, struct types are classes (reference types), so `p` already behaves like a pointer. The `&` operator is more about signaling addressability for mutation or for pointer-type variables.
        -   `&[]int{}` vs `new([]int)`:
            -   `p1 := &[]int{}` -> `let p1: gs.Slice<number> | null = gs.NewSlice(gs.Int, []);` (an initialized, empty slice).
            -   `p2 := new([]int)` -> `let p2: gs.Slice<number> | null = null;` (a nil slice).
            -   **Divergence (Minor):** `&` on a composite literal for slices/maps implies allocation and initialization. `new(Type)` for slices/maps results in `nil`. GoScript aims to match this.
    -   **Array Literal Length & `...`:**
        -   `[10]string{}` -> `gs.NewArray(10, gs.String)`.
        -   `[...]string{"a", "b"}` -> `gs.NewArray(2, gs.String, ["a", "b"])`. The Go compiler resolves `...` to a fixed length; GoScript receives this length.
    -   **Slice Literal Shorthand:** This is a Go compiler interpretation. GoScript receives the `ast.SliceExpr` or `ast.CompositeLit` for a slice.
    -   **Eliding Literal Types:**
        -   Go: `[][]int{{1,2}}`
        -   TS: `gs.NewSlice(gs.SliceInt, [gs.NewSlice(gs.Int, [1,2])])`. TypeScript usually requires explicit construction or type information for nested structures if runtime helpers are involved. Type inference might simplify some cases, but GoScript often generates explicit calls.
        -   **Divergence (Minor):** TypeScript is less permissive with eliding types in nested initializers if custom constructors/factory functions are used. GoScript will typically generate the explicit forms.
    -   **Parsing Ambiguity:** This is a Go parser issue. GoScript consumes an AST where this is already resolved.

### Function literals

-   **Go Specification:**
    -   Anonymous function: `func Signature FunctionBody`.
    -   Cannot declare type parameters (i.e., not generic themselves).
    -   Can be assigned to a variable or invoked directly.
    -   Can form closures (capture surrounding variables).

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   Go: `f := func(x, y int) int { return x + y }`
        -   TS: `const f = (x: number, y: number): number => { return x + y; };` or `const f = function(x: number, y: number): number { return x + y; };`
        -   Handled by `compiler.WriteFuncLitValue`.
    -   **No Type Parameters:** Aligns with TypeScript arrow functions/function expressions which also don't declare their own generics in the same way named generic functions do (though they can be part of a generic variable type: `type MyFunc<T> = (p: T) => T; const x: MyFunc<number> = (p) => p;`).
    -   **Closures:**
        -   Go captures variables by reference (for modification) or value (if not modified after capture, effectively).
        -   TypeScript closures also capture variables from their lexical scope.
        -   **Divergence (Potentially Major for mutable captures):**
            -   If a Go closure captures a variable by reference and modifies it, and that variable is a primitive type or a struct value type, Go uses a heap-allocated "varRef" for the variable.
            -   TypeScript's closure capture for `let`/`const` behaves as expected for reference types. For primitives, it captures the value at the time of definition if the variable is not reassigned, or the binding if it is.
            -   GoScript's `analysis.NeedsVarRefed` and related functions detect variables that need to be heap-allocated (var-refed) due to closure semantics. The generated TS code then uses `gs.VarRef<T>` for these variables (e.g., `let x = new gs.VarRef(0); ... closure uses x.value ...`). This is a significant transformation to ensure Go's closure semantics for mutable captured variables are preserved.
    -   **Overall:** Function literals map well to TS arrow functions or function expressions. The primary complexity is emulating Go's closure capture semantics for mutable variables, which GoScript handles via varRefing analysis and runtime `gs.VarRef` helpers.

### Function literals (Closures - Continued)

-   **Go Specification:**
    -   Function literals are closures: they may refer to variables defined in a surrounding function.
    -   These variables are shared and survive as long as they are accessible.

-   **GoScript & Divergences:**
    -   As previously noted, GoScript handles Go's closure semantics, especially for mutable captured variables (primitives or struct values), by performing an analysis (`analysis.NeedsVarRefed`) and using `gs.VarRef<T>` wrappers in the generated TypeScript. This ensures that modifications within the closure are reflected in the outer scope and vice-versa, mimicking Go's behavior where such variables are effectively heap-allocated.

### Primary expressions

-   **Go Specification:**
    -   Primary expressions are operands for unary and binary expressions.
    -   Defined as:
        ```ebnf
        PrimaryExpr   = Operand |
                        Conversion |
                        MethodExpr |
                        PrimaryExpr Selector |
                        PrimaryExpr Index |
                        PrimaryExpr Slice |
                        PrimaryExpr TypeAssertion |
                        PrimaryExpr Arguments .

        Selector      = "." identifier .
        Index         = "[" Expression [ "," ] "]" .
        Slice         = "[" [ Expression ] ":" [ Expression ] "]" |
                        "[" [ Expression ] ":" Expression ":" Expression "]" .
        TypeAssertion = "." "(" Type ")" .
        Arguments     = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
        ```

-   **GoScript & Divergences:**
    -   **Operand:**
        -   Includes literals, (un)qualified identifiers (variables, constants, functions), and parenthesized expressions.
        -   GoScript maps these directly: literals to TS literals, identifiers to TS variables/functions. `compiler.WriteValueExpr`, `compiler.WriteIdent`.
    -   **Conversion:**
        -   Explicit type conversions like `T(x)`.
        -   GoScript handles this via `compiler.WriteCallExpr` when `CallExpr.Fun` is a type, or specific helper functions for complex conversions (e.g., string to byte slice). For basic numeric conversions, it might be a direct TS cast or function call (e.g., `Number(x)`).
        -   Type parameters: Conversions involving type parameters are complex and rely on runtime type information.
    -   **MethodExpr:** See "Method expressions" section below.
    -   **`PrimaryExpr Selector` (e.g., `x.f`):**
        -   Accessing fields or methods.
        -   Handled by `compiler.WriteSelectorExpr`.
    -   **`PrimaryExpr Index` (e.g., `a[i]`):**
        -   Accessing elements of arrays, slices, strings, or maps.
        -   Handled by `compiler.WriteIndexExpr`.
        -   For maps, `m[key]` might translate to `m.get(key)`. For arrays/slices, `a[i]` to `a.get(i)` or direct access if bounds checking is handled.
    -   **`PrimaryExpr Slice` (e.g., `s[i:j]`):**
        -   Creating sub-slices or sub-strings.
        -   Handled by `compiler.WriteSliceExpr`, typically using a runtime helper like `gs.slice(s, i, j)`.
    -   **`PrimaryExpr TypeAssertion` (e.g., `x.(T)`):**
        -   Asserting the dynamic type of an interface.
        -   Handled by `compiler.WriteTypeAssertExpr`, often using a runtime helper like `gs.typeAssert(x, T_info)`.
    -   **`PrimaryExpr Arguments` (e.g., `f(a,b)`):**
        -   Function or method calls.
        -   Handled by `compiler.WriteCallExpr`.
        -   Includes handling of variadic arguments (`...`).

### Selectors

-   **Go Specification:**
    -   For `x` (not a package name), `x.f` denotes field or method `f` of `x` (or `*x`).
    -   `f` must not be blank identifier.
    -   Selector can refer to field/method of type `T` or an embedded field within `T`. Depth matters for resolution.
    -   **Rules:**
        1.  `x` is `T` or `*T` (T not pointer/interface): `x.f` is shallowest `f` in `T`. Ambiguity (multiple `f` at shallowest depth) is an error.
        2.  `x` is interface `I`: `x.f` is method `f` of `x`'s dynamic value. Error if `f` not in `I`'s method set.
        3.  Exception: If `x` is defined pointer type and `(*x).f` is a valid field selector (not method), `x.f` is shorthand for `(*x).f`.
        4.  All other cases: `x.f` is illegal.
        5.  `nil` pointer `x` and `x.f` is struct field: runtime panic on access/assignment.
        6.  `nil` interface `x`: runtime panic on calling/evaluating `x.f`.

-   **GoScript & Divergences:**
    -   `compiler.WriteSelectorExpr` handles selectors.
    -   **Rule 1 (Shallowest depth):** Go's type checker resolves this. GoScript receives the resolved `types.Selection` object, which directly identifies the target field or method, including those from embedded structs.
        -   TS: `x.f` or `x.embeddedField.f`. GoScript generates the correct access path based on the `types.Selection`.
    -   **Rule 2 (Interface method):**
        -   Go: `i.Method()`.
        -   TS: `i.Method()`. GoScript ensures classes implementing interfaces have corresponding methods. The dynamic dispatch is natural in TS.
    -   **Rule 3 (Pointer shorthand for fields):**
        -   Go: `p.field` where `p` is `*MyStruct`.
        -   TS: `p.field`. GoScript's `WriteSelectorExpr` automatically dereferences pointer types when accessing fields if the `types.Selection` indicates an indirect access.
        -   **No Divergence:** This is handled transparently.
    -   **Rule 5 (Nil pointer field access):**
        -   Go: `var p *Point; v := p.x` (panic).
        -   TS: `let p: Point | null = null; const v = p!.x;` (TS strict null checks might require `!`). Runtime error if `p` is `null`.
        -   GoScript can insert `gs.nilPanicIfNil(p)` before `p.x` to ensure Go-like panic behavior, or rely on TS/JS runtime errors (`TypeError: Cannot read properties of null`). The `gs.nilPanicIfNil` is more explicit.
    -   **Rule 6 (Nil interface method call):**
        -   Go: `var i MyInterface; i.Method()` (panic if `i` is `nil`).
        -   TS: `let i: MyInterface | null = null; i!.Method();`. Runtime error if `i` is `null`.
        -   Similar to pointers, `gs.nilPanicIfNil(i)` can be used.
    -   **Embedded Field Access:** Go flattens embedded fields for direct access (e.g., `t.x` for `t.T0.x`). GoScript replicates this by generating `t.T0_field.x` if `T0` is the name of the embedded field, or directly `t.x` if the `types.Selection` path indicates direct promotion.

### Method expressions

-   **Go Specification:**
    -   If `M` is in method set of type `T`, `T.M` is a function.
    -   Callable as a regular function with `M`'s arguments, plus an initial receiver argument of type `T`.
    -   Example: `adder := T.Add; result := adder(t, 1)` (if `Add` takes one arg).
    -   If `T` is an interface type, `T.M` is valid. The resulting function takes a receiver of type `T` (the interface) and then calls the method on its dynamic type.

-   **GoScript & Divergences:**
    -   **Mapping for Concrete Types:**
        -   Go: `fn := Point.ScaleBy`
        -   TS: `const fn = (p: Point, factor: number): void => { Point.prototype.ScaleBy.call(p, factor); }` or more accurately `(receiver, ...args) => receiver.ScaleBy(...args)`.
        -   GoScript's `compiler.WriteSelectorExpr` handles this when `ast.SelectorExpr.X` is an identifier representing a type.
        -   The generated function needs to correctly handle the `this` context. A wrapper function is typical: `const fn = (recv: Point, arg1: any) => recv.ScaleBy(arg1);`
    -   **Mapping for Interface Types:**
        -   Go: `fn := Stringer.String` (where `Stringer` is an interface)
        -   TS: `const fn = (s: Stringer): string => { return s.String(); }`
        -   This is straightforward as the method is part of the interface contract.
    -   **Value vs. Pointer Receivers:**
        -   If `M` has a pointer receiver `(*T).M`, then `T.M` results in a function whose first argument must be `*T` (or `T` if `T` is an interface that `*T` implements).
        -   If `M` has a value receiver `(T).M`, then `T.M` results in a function whose first argument can be `T` (or `*T`, which will be implicitly dereferenced by Go for the call if `T` is not an interface and the method expects `T`).
        -   GoScript needs to ensure constants are correctly typed in expressions according to Go rules, potentially by inferring the type or applying default types before the TS operation.

### Operators (Continued)

-   **Go Specification (Continued):**
    -   **Implicit Conversion of Untyped Constants:** Except for shifts, if one operand is an untyped constant and the other is not, the constant is implicitly converted to the type of the other operand.
        -   `var i int = 3; var x = i + 7;` (7 becomes int, x is int). `var f float64 = 3.0; var y = f + 7;` (7 becomes float64, y is float64).
    -   **Shift Operations:**
        -   Right operand: integer type or untyped constant representable by `uint`.
        -   Left operand (if untyped constant in non-constant shift): first implicitly converted to type it would assume alone.
            -   `var s uint = 33; var i = 1 << s;` (1 becomes `int` by default).
            -   `var j int32 = 1 << s;` (1 becomes `int32` because of `j`'s type in assignment context).
            -   `var m int = 1.0 << s;` (1.0 becomes `int`, then shift). This is a specific Go rule where a float literal can become an int if it has no fractional part.
            -   Illegal: `1.0 << s` if 1.0 is contextually typed as `float64` (e.g. `var u float64 = 1.0; _ = u << s`).
    -   **Operator Precedence:**
        -   Unary ops: highest. `++`, `--` are statements, not expressions (`*p++` is `(*p)++`).
        -   Binary op levels (highest to lowest):
            1.  `* / % << >> & &^`
            2.  `+ - | ^`
            3.  `== != < <= > >=`
            4.  `&&`
            5.  `||`
        -   Left-to-right associativity for same precedence.
    -   EBNF:
        ```ebnf
        MethodExpr   = ReceiverType "." MethodName .
        ReceiverType = Type .
        ```
    -   `T.Mv` (value receiver `(tv T) Mv()`): yields `func(tv T, a int) int`.
    -   `(*T).Mp` (pointer receiver `(tp *T) Mp()`): yields `func(tp *T, f float32) float32`.
    -   `(*T).Mv` (value receiver method `Mv` on pointer type `*T`): yields `func(tv *T, a int) int`. The function indirects through the receiver `*T` to get a value `T` to pass to the underlying method. The original value pointed to by `*T` is not modified by the method call itself (as `Mv` takes a value receiver).
    -   Illegal: `T.Mp` (pointer receiver method `Mp` on value type `T`) because `Mp` is not in the method set of `T`.
    -   Invocation: `f := T.Mv; f(t, 7)`.
    -   Method expressions on interface types are legal: `I.M` yields `func(recv I, args...) ResultType`.

-   **GoScript & Divergences (Continued):**
    -   **`(*T).Mv` case:**
        -   Go: `fn := (*Point).ScaleByVal` (assuming `ScaleByVal` has `(p Point)` receiver)
        -   TS: `const fn = (pPtr: gs.Ptr<Point>, factor: number): void => { const pVal = gs.deref(pPtr); pVal.ScaleByVal(factor); }` or if `Point` is a class, it might involve creating a temporary value if `ScaleByVal` modifies `this` and Go semantics require the original pointed-to value not to change. However, since `ScaleByVal` has a value receiver, it operates on a copy. So, `gs.deref(pPtr).ScaleByVal(factor)` is more direct if `ScaleByVal` is on the class `Point`.
        -   The key is that the function signature expects a pointer `*T`, but the method `Mv` expects `T`. GoScript needs to generate the dereference.
    -   **Illegal `T.Mp`:** This is a Go compile-time error. GoScript relies on the Go compiler's type checking, so it wouldn't encounter this case for valid Go code.
    -   **Interface Method Expression:**
        -   Go: `fn := Stringer.String`
        -   TS: `const fn = (s: Stringer): string => { return s.String(); }`. This maps cleanly.

### Method values

-   **Go Specification:**
    -   If `x` has static type `T` and `M` is in `T`'s method set, `x.M` is a method value.
    -   It's a function value callable with the same arguments as `x.M()`.
    -   `x` (the receiver) is evaluated and *saved* during the evaluation of `x.M`. The saved copy is used for later calls.
    -   Example:
        ```go
        t := new(T)
        s := S{T: t} // S embeds *T
        f := t.M     // receiver *t is evaluated and stored in f
        g := s.M     // receiver *(s.T) (which is *t) is evaluated and stored in g
        *t = 42      // does not affect stored receivers in f and g
        ```
        (Note: The Go spec example `print(t)` inside `M` for `type T int` means `M` has a `T` receiver. If `t` is `*T`, then `t.M` implicitly dereferences `*t` to get a `T` value, and this *value* is stored. If `M` had a `*T` receiver, then the pointer `t` itself would be stored.)
        Let's clarify with the spec's `T int` and `func (t T) M()`:
        `var valT T; f := valT.M;` stores `valT`.
        `ptrT := new(T); f := ptrT.M;` evaluates `*ptrT` and stores that value.
    -   `t.Mv` (value receiver `(tv T) Mv()` on `t` of type `T`): yields `func(a int) int`. The receiver `t` is captured.
    -   `pt.Mp` (pointer receiver `(tp *T) Mp()` on `pt` of type `*T`): yields `func(f float32) float32`. The receiver `pt` is captured.

-   **GoScript & Divergences:**
    -   **Mapping:**
        -   Go: `f := myInstance.MyMethod`
        -   TS: `const f = myInstance.MyMethod.bind(myInstance);` or `const f = (...args: any[]) => myInstance.MyMethod(...args);`
        -   `compiler.WriteSelectorExpr` handles this when `types.Selection.Kind() == types.MethodVal`.
    -   **Receiver Evaluation and Storage:**
        -   **Value Receiver on Value Type (`t.Mv` where `t` is `T`):
            -   Go: `t_copy := t; f := func(args...) { t_copy.Mv(args...) }` (conceptually). The value of `t` at the time of `t.Mv` is captured.
            -   TS: `const t_copy = t.clone(); const f = (...args) => t_copy.Mv(...args);` if `t` is a struct requiring cloning for value semantics. If `T` is a primitive, `const t_copy = t;`.
            -   **Divergence/Implementation:** GoScript needs to ensure value semantics. If `T` is a struct type (mapped to a class), `myInstance.MyMethod.bind(myInstance)` binds the *reference*. To match Go, if `Mv` is a value-receiver method, a *clone* of `myInstance` should be bound if `myInstance` is a value type.
                `let receiver_copy = gs.clone(myInstance); const f = receiver_copy.Mv.bind(receiver_copy);`
        -   **Pointer Receiver on Pointer Type (`pt.Mp` where `pt` is `*T`):
            -   Go: `pt_captured := pt; f := func(args...) { pt_captured.Mp(args...) }`. The pointer `pt` is captured.
            -   TS: `const pt_captured = pt; const f = (...args) => pt_captured!.Mp(...args);` (assuming `pt` can be `null` in TS). This maps naturally.
        -   **Value Receiver on Pointer Type (`pt.Mv` where `pt` is `*T`):
            -   Go: `val_of_pt := *pt; f := func(args...) { val_of_pt.Mv(args...) }`. The value `*pt` is captured.
            -   TS: `const val_of_pt = gs.clone(gs.deref(pt)); const f = (...args) => val_of_pt.Mv(...args);`. Requires dereferencing and cloning.
        -   **Pointer Receiver on Addressable Value Type (`t.Mp` where `t` is `T`):
            -   Go: `addr_of_t := &t; f := func(args...) { addr_of_t.Mp(args...) }`. The address `&t` is captured.
            -   TS: This is tricky. If `t` is a class instance, `t` is already a reference. If `t` is a primitive that needs varRefing for addressability, `const varRef_t = gs.varRef(t); const f = (...args) => varRef_t.value.Mp(...args);` (assuming `Mp` is on the varrefed value's type, which is complex). More likely, `const f = t.Mp.bind(t)` if `Mp` is correctly on `T`'s prototype and handles value/pointer semantics internally.
                The Go compiler takes care of `(&t).Mp()`. So for `t.Mp`, it's `(&t)` that's captured.
                If `t` is a struct value, GoScript might represent `t` as a class. `t.Mp` would mean `Mp` is a method on the class. `t.Mp.bind(t)` captures the reference `t`. This matches Go's behavior where `(&t)` is used.
    -   `compiler.WriteSelectorExpr` needs to be aware of these nuances to generate the correct binding or wrapper function, potentially involving `gs.clone` or `gs.varRefValueReceiverMethod` helpers.
    -   The key difference from method expressions is that the receiver is pre-bound.
    -   The Go spec example `*t = 42` not affecting `f` and `g` implies that for `f := t.M` where `t` is `*T` and `M` has a `T` receiver, `*t` is read *at the time of `t.M`* and this value is what `M` operates on. If `M` had a `*T` receiver, then the pointer `t` itself would be bound.
        -   If `T` is `int`, `func (tv T) M()`, and `t_ptr := new(T); *t_ptr = 10; f := t_ptr.M; *t_ptr = 42; f();` should use `10`.
        -   GoScript: `let t_ptr = gs.New(gs.Int, 10); const receiver_val = gs.deref(t_ptr); const f = () => MyTImpl.prototype.M.call(receiver_val); gs.set(t_ptr, 42); f();`

### Method values (Continued)

-   **Go Specification (Continued):**
    -   `pt.Mv` (value receiver method on pointer `pt`): equivalent to `(*pt).Mv`. The value `*pt` is captured.
        -   Yields `func(a int) int`.
    -   `t.Mp` (pointer receiver method on addressable value `t`): equivalent to `(&t).Mp`. The address `&t` is captured.
        -   Yields `func(f float32) float32`.
    -   `makeT().Mp` is invalid if `makeT()` result is not addressable.
    -   Method values from interface types are legal: `var i interface{M(int)}; f := i.M; f(7)`. The interface value `i` (which includes its dynamic type and value) is captured.

-   **GoScript & Divergences (Continued):**
    -   **`pt.Mv` (Value Receiver, Pointer Instance):**
        -   Go: `f := pt.Mv` captures value `*pt`.
        -   TS: `const derefed_pt = gs.clone(gs.deref(pt)); const f = (...args) => derefed_pt.Mv(...args);`
        -   This requires explicit dereference and clone (for value semantics of the receiver) at the time of method value creation.
    -   **`t.Mp` (Pointer Receiver, Addressable Value Instance):**
        -   Go: `f := t.Mp` captures `&t`.
        -   TS: If `t` is a class instance (reference type), `const f = t.Mp.bind(t);` works. `t` itself is the "address".
        -   If `t` were a basic type or struct needing varRefing to be addressable for a pointer receiver method, Go handles this. GoScript would need to reflect this, possibly by varRefing `t` if `Mp` expects a pointer to a primitive. However, methods are typically on defined (struct/named) types. For a struct `T` mapped to a class, `t.Mp.bind(t)` is idiomatic.
    -   **Non-addressable `makeT().Mp`:** This is a Go compile-time error. GoScript would expect valid Go AST.
    -   **Interface Method Value:**
        -   Go: `f := i.M` captures `i`.
        -   TS: `const captured_i = i; const f = (...args) => captured_i!.M(...args);` (assuming `i` can be `null`). This maps well. The dynamic dispatch is inherent.

### Method expressions

-   **Go Specification:**
    -   If `M` is in method set of type `T`, `T.M` is a function callable like a regular function with `T` as its first argument.
    -   Signature of `T.M` is `func(T, A..., A) (R..., R)`.
    -   If `M` is in method set of `*T`, `(*T).M` is a function with `*T` as first argument.
    -   Signature of `(*T).M` is `func(*T, A..., A) (R..., R)`.
    -   Example: `Point.Distance` (if `Distance` is method of `Point`).
    -   `ReceiverType` in `MethodExpr = ReceiverType "." MethodName` cannot be a type parameter.
    -   EBNF:
        ```ebnf
        MethodExpr   = ReceiverType "." MethodName .
        ReceiverType = TypeName | "(" "*" TypeName ")" | "(" ReceiverType ")" .
        ```

-   **GoScript & Divergences (`compiler.WriteSelectorExpr` for method expressions):**
    -   **Representation:** `T.M` or `(*T).M` translates to a TS function value.
        -   `Point.Distance` could become `(p: Point_TS, arg1: A1_TS, ...) => Point_TS.prototype.Distance.call(p, arg1, ...)` or a similar construct.
        -   If `Distance` is a method of `*Point`, then `(*Point).Distance` becomes `(p_ptr: Pointer<Point_TS>, arg1: A1_TS, ...) => { /* deref p_ptr and call */ }`.
    -   **`this` Context:** The generated TS function must correctly handle the receiver.
    -   **ReceiverType Restrictions:** TS generics in class/interface definitions don't have this direct "cannot contain type parameters" restriction for the type itself when referencing its methods in a "method expression" style. If `T` is generic `T<U>`, then `T.M` would conceptually involve `T<U>`. GoScript would need to handle instantiation if `T` is generic.
    -   **No Major Divergence:** This concept maps to higher-order functions or method extraction in TS. The key is generating the correct wrapper function with the appropriate signature and receiver handling.

### Method values

-   **Go Specification:**
    -   If `x` has static type `T` and `M` is in method set of `T`, `x.M` is a "method value".
    -   `x.M` is a function value callable with same args as `M`, but with `x` implicitly passed as receiver.
    -   Applies to types `T` or `*T` (where `T` is not pointer or interface).
    -   Expression `x.M` can be invoked or assigned.
    -   Example: `p := &Point{1,2}; dist := p.Distance; d := dist(Point{3,4});` (`dist` is `p.Distance` bound to `p`).
    -   If `x` is addressable and `&x`'s method set contains `M`, then `x.M` is shorthand for `(&x).M`.
    -   For interface types `I`, if `x` of type `I` has `M` in its method set, `x.M` is a method value with `x` as receiver.

-   **GoScript & Divergences (`compiler.WriteSelectorExpr` for method values):**
    -   **Mapping to TS:**
        -   `x.M` is equivalent to `x.M.bind(x)` in TS, or simply `(...args) => x.M(...args)`.
        -   This creates a closure where `x` (the GoScript representation of the Go variable `x`) is captured.
        -   Example: `const p_gs = gs.NewPointer(new Point(1,2)); const distFunc = p_gs.value.Distance.bind(p_gs.value);` (assuming `Distance` is on `Point` and `p_gs.value` is the `Point` instance).
        -   If methods are translated as arrow functions on the instance, binding might not be needed, but GoScript typically uses prototype methods for structs.
    -   **Addressability for Shorthand:**
        -   Go: `t.M` can mean `(&t).M`.
        -   TS: No direct addressability concept. If `t` is a value type in GoScript (e.g. plain object for struct), and `M` expects a pointer receiver, GoScript would need to handle the implicit `&t` when `t.M` is evaluated to create the method value. This means the method value for `t.M` would capture the *varrefed* (pointer) version of `t`.
        -   `compiler.WriteSelectorExpr` needs to check if `x.Sel` is a method and if an implicit address operation is needed.
    -   **Interface Method Values:**
        -   If `x_ts` is the TS representation of Go interface `x`, then `x_ts.M.bind(x_ts)` or `(...args) => x_ts.M(...args)` works. The dynamic dispatch is handled by the interface object itself.
    -   **No Major Divergence:** The concept of a method value (a function bound to a specific receiver instance) is common and easily represented in TS using `bind` or arrow function closures. GoScript needs to ensure the correct `this` context for the generated function and handle implicit addressing.

### Index expressions

-   **Go Specification:**
    -   `a[x]` denotes element of array, `*array`, slice, string, or map `a` indexed by `x`.
    -   **If `a` is not map/type parameter:**
        -   `x`: untyped constant, integer, or integer-only type parameter.
        -   Constant `x`: non-negative, representable by `int`, given type `int` if untyped.
        -   `x` in range: `0 <= x < len(a)`.
    -   **Array `A`:**
        -   Constant `x` must be in range.
        -   Runtime panic if `x` out of range.
        -   `a[x]` is element, type is `A`'s element type.
    -   **`*Array`:** `a[x]` is shorthand for `(*a)[x]`.
    -   **Slice `S`:**
        -   Runtime panic if `x` out of range.
        -   `a[x]` is element, type is `S`'s element type.
    -   **String:**
        -   Constant `x` must be in range if string `a` is constant.
        -   Runtime panic if `x` out of range.
        -   `a[x]` is non-constant `byte` value at index `x`.
        -   `a[x]` cannot be assigned to.
    -   **Map `M`:**
        -   `x`'s type assignable to key type of `M`.
        -   If `x` present, `a[x]` is element.
        -   If map `nil` or `x` not present, `a[x]` is zero value for element type.
    -   **Type Parameter `P`:**
        -   `a[x]` must be valid for all types in `P`'s type set.
        -   Element types of all types in `P`'s type set must be identical (string element type is `byte`).
        -   If map type in set, all types must be maps with identical key types.
        -   `a[x]` is element of instantiated type argument.
        -   Cannot assign to `a[x]` if `P`'s type set includes string types.
    -   **Map assignment form `v, ok = a[x]`:** yields additional untyped boolean `ok`.
    -   Assigning to element of `nil` map: runtime panic.

-   **GoScript & Divergences:**
    -   Handled by `compiler.WriteIndexExpr`.
    -   **Arrays/Slices/Strings:**
        -   `a[x]` maps to `a.get(x)` or `gs.index(a, x)` for runtime bounds checking and consistent panic behavior.
        -   String indexing `s[i]`: Go returns `byte`. TS `s.charCodeAt(i)` returns `number` (UTF-16 code unit).
            -   **Divergence:** `s.charCodeAt(i)` is not a byte. `new TextEncoder().encode(s[i])[0]` would be closer but inefficient. GoScript likely uses a helper `gs.stringIndex(s, i)` returning `number` (byte value).
        -   String element `a[x]` cannot be assigned to: TS strings are immutable, so this aligns.
    -   **Pointer to Array `(*a)[x]`:** GoScript's `WriteIndexExpr` handles automatic dereferencing.
    -   **Maps:**
        -   `a[x]` for reading: `a.get(x)` which would return `V | undefined`. To match Go's zero value on miss, `a.get(x) ?? zeroValueForV`.
        -   `a[x] = val`: `a.set(x, val)`.
        -   `v, ok = a[x]`: `const [v, ok] = [a.get(x) ?? zeroValueForV, a.has(x)];` (or a helper `gs.mapIndex(a,x)` returning `[V, boolean]`). `compiler.writeChannelReceiveWithOk` (misnamed?) or similar logic is used for this pattern.
        -   Nil map panic: `gs.mapSet(m, k, v)` and `gs.mapGet(m, k)` helpers would check for `nil` map and panic.
    -   **Type Parameters:** Complex. Requires runtime type information about the instantiated type of `P` to perform the correct index operation (array, map, string) and type checks. GoScript would likely dispatch to different helper implementations based on `P`'s runtime type.
    -   **Panics:** GoScript uses runtime helpers (e.g., in `@goscript/builtin`) to emulate Go's panic behavior for out-of-range access or nil map assignments.

### Slice expressions

-   **Go Specification:**
    -   Construct substring/slice from string, array, `*array`, or slice.
    -   Two forms: simple `a[low:high]`, full `a[low:high:max]`.
    -   **Type Parameter Operand:**
        -   If type set includes strings, may also include `[]byte`. Slice op must be valid for string.
        -   Otherwise, all types in set must have same underlying type, slice op must be valid for that.
    -   **Simple Slice `a[low:high]`:**
        -   Result has indices `0` to `high-low-1`. Length is `high-low`.

-   **GoScript & Divergences:**
    -   Handled by `compiler.WriteSliceExpr`.
    -   **Mapping:** `a[low:high]` typically maps to `gs.slice(a, low, high)`.
        -   This helper needs to handle strings, arrays, and slices correctly.
        -   For strings: TS `s.substring(low, high)` or `s.slice(low, high)`.
        -   For arrays/TS arrays: `a.slice(low, high)`.
    -   **Type Parameters:** Similar to index expressions, requires runtime type information to dispatch to the correct slicing implementation.
    -   **Underlying Array Sharing (for Go slices):**
        -   Go slices `s1 := arr[0:5]` and `s2 := arr[2:7]` share the same underlying array. Modifications through `s1` can be visible via `s2`.
        -   TS `array.slice()` creates a *shallow copy*, not a view into the original array.
        -   **Major Divergence:** To emulate Go's slice semantics (shared underlying array and capacity), GoScript's `gs.Slice<T>` type and `gs.slice()` helper are crucial. `gs.Slice` would internally hold a reference to the underlying array/data source, an offset, length, and capacity.

### Slice expressions (Continued)

-   **Go Specification (Continued):**
    -   **Simple Slice `a[low:high]` (Continued):**
        -   Omitted `low` defaults to 0, omitted `high` defaults to `len(a)`. `a[:]` is `a[0:len(a)]`.
        -   If `a` is `*[N]T`, `a[low:high]` is `(*a)[low:high]`.
        -   Indices in range: `0 <= low <= high <= len(a)` for arrays/strings. For slices, upper bound is `cap(a)`.
        -   Constant indices: non-negative, representable by `int`. For arrays/constant strings, must be in range. If both constant, `low <= high`.
        -   Runtime panic if out of range.
        -   Result is non-constant of same type (string or slice). For untyped string operand, result is `string`.
        -   If operand is array, it must be addressable; result is slice with same element type.
        -   If sliced operand is `nil` slice, result is `nil` slice.
        -   Resulting slice shares underlying array with operand.
            -   `s1 := arr[3:7]`, `s2 := s1[1:4]`. `&s2[1] == &arr[5]`.
    -   **Full Slice `a[low:high:max]` (not for strings):**
        -   Constructs slice like `a[low:high]`, but capacity is `max - low`.
        -   Only `low` may be omitted (defaults to 0).
        -   If `a` is `*[N]T`, `a[low:high:max]` is `(*a)[low:high:max]`.
        -   If operand is array, it must be addressable.
        -   Indices in range: `0 <= low <= high <= max <= cap(a)`.
        -   Runtime panic if out of range.

-   **GoScript & Divergences (Continued):**
    -   **Simple Slice Defaults:** `gs.slice(a, low, high)` helper needs to handle default `low` (0) and `high` (`gs.len(a)`).
    -   **Pointer to Array Slicing:** `WriteSliceExpr` should handle dereferencing: `gs.slice(gs.deref(a), low, high)`.
    -   **Index Range Checks:** `gs.slice` must perform runtime checks and panic as per Go rules.
        -   `cap(a)` for slices: `gs.Slice<T>` needs a `capacity` property and `gs.cap(a)` helper.
    -   **Addressable Array for Slicing:** Go requires array to be addressable to take a slice from it.
        -   TS arrays are reference types. If GoScript maps Go arrays to TS arrays/`gs.Array`, this is generally fine.
        -   If a Go array is a value type (e.g. struct field), it needs to be "on the heap" or addressable. GoScript's representation of structs and arrays will determine this. If structs are classes, their array fields are part of the class instance.
    -   **Nil Slice Slicing:** `gs.slice(nilSlice, ...)` should return `null` (or GoScript's `nil` slice representation).
    -   **Underlying Array Sharing & Capacity (Full Slice):**
        -   This is the core challenge for `gs.Slice<T>` and `gs.slice(a, low, high, max?)`.
        -   `gs.slice(a, low, high)`: capacity is `gs.cap(a) - low`.
        -   `gs.slice(a, low, high, max)`: capacity is `max - low`.
        -   The `gs.Slice` object must contain:
            -   Reference to the original data source (e.g., a TS array or another `gs.Slice`'s underlying data).
            -   Offset into that data source.
            -   Length.
            -   Capacity.
        -   Modifications to elements of a `gs.Slice` must affect the original data source if it's shared.
        -   Example: `t := a[1:3:5]` (where `a` is `[5]int{1,2,3,4,5}`)
            -   `t` length 2 (`t[0]=2, t[1]=3`), capacity 4 (`5-1`).
            -   `gs.slice(a, 1, 3, 5)` would create a `gs.Slice` pointing to `a`'s data, offset 1, length 2, capacity 4.

### Type assertions

-   **Go Specification:**
    -   `x.(T)`: Asserts `x` (interface type, not type parameter) is not `nil` and stores value of type `T`.
    -   If `T` not interface: asserts dynamic type of `x` is identical to `T`. `T` must implement `x`'s interface type.
    -   If `T` is interface: asserts dynamic type of `x` implements interface `T`.
    -   If assertion holds: value is `x`'s stored value, type is `T`.
    -   If false: runtime panic.
    -   Example: `var x interface{} = 7; i := x.(int)`
    -   Illegal: `y.(string)` if `string` doesn't implement `y`'s interface type.
    -   **Assignment form `v, ok = x.(T)`:**
        -   `ok` (untyped boolean) is `true` if assertion holds, `false` otherwise.
        -   If `false`, `v` is zero value for `T`. No panic.

-   **GoScript & Divergences:**
    -   Handled by `compiler.WriteTypeAssertExpr` and `compiler.writeTypeAssert` helper.
    -   **Mapping `x.(T)`:**
        -   `gs.typeAssert(x, T_descriptor)`: This runtime helper would check the dynamic type of `x` against `T_descriptor`.
        -   `T_descriptor` would be a runtime representation of type `T`, including its methods if it's an interface.
        -   If `x` is `null` or type doesn't match, `gs.typeAssert` panics.
        -   Otherwise, it returns `x` (cast to `T` in TS).
    -   **Mapping `v, ok = x.(T)`:**
        -   `[v, ok] = gs.typeAssertWithOk(x, T_descriptor)`
        -   `gs.typeAssertWithOk` returns `[value, boolean]`. If assertion fails, returns `[zeroValueForT, false]`.
    -   **Implementation Details:**
        -   GoScript needs a robust runtime type information system. Each value likely carries a reference to its type descriptor.
        -   Interface implementation checks (`implements(dynamicTypeOfX, T_interface_descriptor)`) are key.
        -   For non-interface `T`, it's an exact type match: `dynamicTypeOfX === T_descriptor`.
    -   **Static Check `T` must implement `x`'s type:** This is a Go compiler check. GoScript relies on valid Go AST.

### Calls

-   **Go Specification:**
    -   `f(a1, a2, ... an)` where `f` has function type `F`.
    -   (Details to follow in next spec segment)

-   **GoScript & Divergences:**
    -   Handled by `compiler.WriteCallExpr`.
    -   Generally maps directly to TypeScript function calls: `f(a1, a2, ..., an)`.
    -   Considerations:
        -   Variadic arguments.
        -   Multi-value returns.
        -   Deferred function calls (panic/recovery).
        -   Goroutines.
    -   These will be detailed as the spec section on Calls unfolds.

### Calls (Continued)

-   **Go Specification (Continued):**
    -   Arguments evaluated before function call. Type of expression is result type of `F`.
    -   Method invocation: selector on receiver value.
    -   Generic function must be instantiated before call/use as value.
    -   If `f` is type parameter: all types in its type set must have same underlying function type; call must be valid.
    -   Evaluation order: function value, then arguments (usual order).
    -   New storage allocated for parameters and results. Arguments assigned to parameters.
    -   Calling `nil` function value: runtime panic.
    -   **Special Case `f(g(params_of_g))`:** If `g`'s return values match `f`'s parameters in number and assignability, they are passed directly. `g` must have >= 1 return value. `f` must have no other params. If `f` has final `...` param, it gets remaining `g` returns.
    -   **Method Call `x.m()`:** Valid if method set of `x` contains `m` and args assignable.
        -   If `x` addressable and `&x`'s method set contains `m`, `x.m()` is `(&x).m()`.
    -   No distinct method type or method literals.

-   **GoScript & Divergences (Continued):**
    -   **Argument Evaluation & Assignment:** Standard in TS.
    -   **Generics & Instantiation:** Go 1.18+ feature.
        -   GoScript needs to handle instantiation of generic functions and types.
        -   This might involve generating specific TS functions/classes for each instantiation, or using TS generics if they map cleanly.
        -   `compiler.WriteCallExpr` needs to detect calls to generic functions and ensure type arguments are resolved (explicitly or via inference).
    -   **Type Parameter as Function:** Requires runtime type information to confirm the type parameter instance is a function and to call it.
    -   **Nil Function Panic:** `f(...)` in TS: if `f` is `null` or `undefined`, TS throws a `TypeError`. This is similar to Go's panic. GoScript can rely on this or wrap calls in a helper for consistent error messages: `gs.call(f, ...args)`.
    -   **Special Case `f(g())`:**
        -   Go: `f(g())` where `g` returns `(r1, r2)` and `f` takes `(p1, p2)` becomes `f(r1, r2)`.
        -   TS: Functions return single values (or an array/object for multiple values).
        -   **Divergence:** GoScript must transform `f(g())`. If `g` returns `[val1, val2]`, then `f(...gs.multiRet(g()))` or `const ret_g = g(); f(ret_g[0], ret_g[1])`. The `compiler.WriteCallExpr` needs to detect this pattern.
        -   If `g` returns multiple values and `f` is variadic: `f(...g())` in Go. TS: `f(...gs.multiRet(g()))`.
    -   **Method Call `x.m()` with Auto-Addressing:**
        -   Go: `var p Point; p.Scale(3.5)` becomes `(&p).Scale(3.5)` if `Scale` has pointer receiver.
        -   TS: If `Point` is a class, `p.Scale(3.5)` works directly. If `Scale` modifies `p`, it modifies the instance `p` refers to.
        -   If `Point` is a struct (value type) and GoScript maps it to an object literal or a class that needs explicit varRefing for pointer receivers, `WriteCallExpr` (via `WriteSelectorExpr` logic) needs to handle this. `gs.callMethod(p, "Scale", [3.5])` could manage this, taking address if needed.
    -   **No Method Type/Literals:** Aligns with TS; methods are functions bound to objects.

### Passing arguments to `...` parameters

-   **Go Specification:**
    -   `func f(p ...T)`: within `f`, `p` is `[]T`.
    -   If no args for `p`, `p` is `nil`.
    -   Else, `p` is new `[]T` with actual arguments. Length/capacity is num args.
    -   `Greeting("nobody")` -> `who` is `nil`.
    -   `Greeting("hello:", "Joe", "Anna")` -> `who` is `[]string{"Joe", "Anna"}`.
    -   If final arg `s` is `[]T` followed by `...` (e.g., `Greeting("msg:", s...)`):
        -   `s` is passed unchanged. No new slice. `who` has same value and underlying array as `s`.

-   **GoScript & Divergences:**
    -   **Mapping:** TS rest parameters `...p: T[]` behave very similarly.
        -   `func greeting(prefix: string, ...who: string[])`
    -   **No Args for `...p`:**
        -   Go: `p` is `nil`.
        -   TS: `who` is `[]` (empty array), not `null` or `undefined`.
        -   **Divergence:** `compiler.WriteCallExpr` or the function prologue in GoScript needs to adjust. If `who.length === 0` from a call with no variadic args, set `who = null`.
        -   Alternatively, generated code inside `Greeting` would check `if (who && who.length === 0) { who = null }` if strict `nil` equivalence is needed. More likely, GoScript adapts to treat empty array and `nil` slice similarly where idiomatic.
    -   **Passing Slice with `...`:**
        -   Go: `Greeting("msg:", s...)`
        -   TS: `greeting("msg:", ...s)` (spread syntax). This works directly.
        -   **Underlying Array:** TS spread `...s` creates a shallow copy for function arguments. If `s` is a `gs.Slice` that represents a view, `...s.toArray()` might be needed, or `gs.callVariadic(Greeting, "msg:", s)`.
        -   If `s` is a `gs.Slice`, passing `s` directly (if `...T` becomes `gs.Slice<T>`) would preserve sharing if `gs.Slice` is designed for it. However, Go's spec says "value passed is a new slice ... whose successive elements are the actual arguments" unless `s...` syntax is used with an existing slice.
        -   If `p` is `...T` (so `[]T` in Go func), and we call `f(sliceVal...)`:
            -   Go: `p` *is* `sliceVal` (same underlying array).
            -   TS: `f(...sliceVal)` makes `p` a *copy* of `sliceVal`.
            -   **Divergence:** For `s...` to truly share, the `gs.Slice` itself would need to be passed, and the function signature adapted, or runtime helpers used. `gs.callWithSpread(f, args, s_gsSlice)` could handle this.

### Instantiations

-   **Go Specification ([Go 1.18+]):**
    -   Generic function/type instantiated by substituting type arguments for type parameters.
    -   Two steps:
        1.  Substitute type args for type params in declaration (entirely, incl. param list itself).
        2.  Substituted type args must satisfy constraints (instantiated if needed). Else, failure.
    -   Instantiation results in new non-generic named type or non-generic function.
    -   Type args can be explicit or inferred.
    -   Can omit if func is: called, assigned to known type var, passed as arg, returned as result.

-   **GoScript & Divergences:**
    -   **Mapping to TS Generics:** TypeScript generics are powerful.
        -   `func Scale[N number | bigint](s []N, f N) []N` could map to `function scale<N extends number | bigint>(s: N[], f: N): N[]`.
    -   **Substitution & Constraint Checking:**
        -   TS compiler does this for TS generics. If GoScript translates Go generics to TS generics, it relies on `tsc`.
        -   If GoScript generates monomorphized code (specific versions for each type instantiation), then GoScript's compiler performs these checks during its analysis phase before code generation.
    -   **Type Inference:** TS also has robust type inference for generics. This aligns well.
    -   **Generating Non-Generic Types/Functions:**
        -   If using TS generics, the "new non-generic type/function" is effectively the TS generic specialized by the TS compiler at usage sites.
        -   If monomorphizing, GoScript would generate distinct TS types/functions like `scale_int(s: number[], f: number): number[]`, `scale_float64(s: number[], f: number): number[]`.
    -   **Challenges:**
        -   Go's structural typing vs. TS's nominal/structural options.
        -   Interface constraints in Go vs. `extends` in TS.
        -   Type embedding and method promotion with generics.
        -   Go's `comparable` constraint. TS doesn't have a direct equivalent that restricts to only comparable types in the same way.
        -   The Go compiler resolves instantiations. GoScript receives already (or to-be) instantiated AST if dealing with compiled Go, or needs to perform this resolution if processing generic Go source directly.

### Instantiations (Continued)

-   **Go Specification ([Go 1.18+]) (Continued):**
    -   If type args list absent/partial, missing args must be inferable.
    -   `x := sum` is illegal if `sum` is generic and `x`'s type unknown.
    -   `intSum := sum[int]` ok. `b := sum[float64](2.0, 3)` ok. `c := sum(b, -1)` infers type from `b`.
    -   `var f sumFunc = sum` infers type args from `sumFunc`'s signature.
    -   Partial type arg list: not empty, prefix of full list. Args omitted "right to left".
        -   `f1 := apply[[]int]` infers `E` from `S = []int`.
    -   Generic type: all type args must always be provided explicitly. (Unlike generic functions).

-   **GoScript & Divergences (Continued):**
    -   **Type Argument Inference for Functions:**
        -   If GoScript uses TS generics, TS's inference mechanism is leveraged.
            -   `const intSum = sum<number>;`
            -   `const b = sum<number>(2.0, 3);`
            -   `const c = sum(b, -1);` (TS infers from `b`)
            -   `const f: SumFunc = sum;` (TS infers from `SumFunc` type)
        -   If GoScript monomorphizes, its own type inference logic must be robust enough to match Go's rules before generating specific versions.
    -   **Partial Type Argument Lists:** TS doesn't directly support omitting type arguments "right to left" in the same way. Usually, either all are provided, or all are inferred. If some are provided, it's typically from left to right.
        -   `apply[[]int]` (Go) to infer `E`: In TS, if `apply<S, E>(...)`, `apply<number[]>(...)` would require `E` to be inferred or specified. If `E` can be inferred from `S` (e.g. `S extends E[]`), TS might handle it.
        -   **Divergence/Complexity:** Go's specific partial list rules might require GoScript to do more work to map to TS generics or its monomorphization strategy.
    -   **Explicit Type Args for Generic Types:**
        -   Go: `type List[T any] struct { ... }; var l List[int]`
        -   TS: `class List<T> { ... }; let l: List<number>;` or `let l = new List<number>();`
        -   This aligns well. TS requires type arguments for generic types if not inferable from constructor arguments (which is often the case for type declarations).

### Type inference

-   **Go Specification ([Go 1.18+]):**
    -   Omitted type args for generic functions can be inferred from context (args, constraints).
    -   Succeeds if missing args inferred AND instantiation with them succeeds.
    -   Uses type relationships: arg assignable to param, type arg satisfies constraint.
    -   Each pair of matched types -> type equation. Solving equations -> inferring type args.
    -   Example: `func dedup[S ~[]E, E comparable](S) S; type Slice []int; var s Slice; s = dedup(s)`
        -   Equations:
            1.  `Slice <sub>A</sub> S` (assignability: `typeof(parameter) <sub>A</sub> typeof(argument)`)
            2.  `S <sub>C</sub> ~[]E` (constraint satisfaction)
        -   Solve for bound type params `S, E`: Infers `S  Slice`, `E  int`.
    -   Bound type parameters: those of functions needing instantiation without explicit type args.
    -   Supports: calls of generic funcs, assignments of generic funcs to typed vars, passing generic funcs as args, returning generic funcs.
    -   **Equations Generated:**
        -   Call `f(a0, a1, ...)`: For each pair `(ai, pi)` where `ai` not untyped const: `typeof(pi) <sub>A</sub> typeof(ai)`.
            -   If `ai` is untyped const `cj` and `typeof(pi)` is bound type param `Pk`: `(cj, Pk)` collected separately.
        -   Assignment `v = f` (generic `f` to non-generic func type `v`): `typeof(v) <sub>A</sub> typeof(f)`.
        -   Return `f` (generic `f` as result for non-generic func type `r`): `typeof(r) <sub>A</sub> typeof(f)`.
        -   Each type param `Pk` and constraint `Ck`: `Pk <sub>C</sub> Ck`.

-   **GoScript & Divergences:**
    -   **Leveraging TS Inference:** If GoScript maps Go generics to TS generics, it heavily relies on TypeScript's own type inference, which is quite advanced.
        -   TS inference considers assignability, constraints (`extends`), argument types, return types, and contextual typing.
    -   **Type Equation Solving:** This is a formal model of what a type inferencer (like TS's or one GoScript might need for monomorphization) does.
        -   If GoScript implements its own inference (e.g., for monomorphization or to exactly replicate Go semantics before TS step), it would need a similar equation-solving mechanism.
    -   **Untyped Constants:**
        -   Go: Untyped constants get their type from context. `const c = 10; var x int = c; var y float64 = c;`
        -   TS: Numeric literals like `10` have type `number`. No direct "untyped" concept that then gets refined.
        -   **Divergence:** Handling untyped constants in type inference for generic parameters requires special care. If `func foo[T any](v T)` is called `foo(10)`, Go infers `T` based on later use or other constraints. TS would likely infer `number`. If `T` needs to be, say, `int32` specifically, GoScript would need to ensure this.
        -   The "collected separately" part for untyped constants implies a multi-pass or refinement step in Go's inference.
    -   **Assignability (<sub>A</sub>) vs. Constraint Satisfaction (<sub>C</sub>):**
        -   TS `extends` keyword covers constraint satisfaction. Assignability is the standard type checking.
    -   **Complexity:** Implementing a type inference system that perfectly matches Go's, especially with its two-step instantiation and specific rules for untyped constants and type unification (detailed later in spec), is a significant compiler engineering task. If relying on TS generics, there might be subtle differences in inferred types or error reporting compared to a pure Go compiler.
    -   **GoScript's Approach:** The most pragmatic approach for GoScript is likely to translate Go generics to TS generics and rely on `tsc` for inference and type checking, accepting minor divergences if they don't break correctness for common patterns. For complex or ambiguous cases, GoScript might need to guide TS by adding explicit type annotations during transpilation.

### Type inference (Continued)

-   **Go Specification ([Go 1.18+]) (Continued):**
    -   **Two Phases for Inference:**
        1.  Solve type equations for bound type params using Type Unification. If fails, inference fails.
        2.  For remaining unbound params `Pk` with collected untyped const pairs `(cj, Pk)`:
            -   Determine constant kind of `cj`s.
            -   Type arg for `Pk` is default type for that kind.
            -   If conflicting const kinds, inference fails.
    -   If not all type args found after 2 phases, inference fails.
    -   **Simplification:** Inferred type arg `Ak` for `Pk` might itself contain bound params. Repeatedly substitute until `Ak` is free of bound params.
    -   **Cyclic References:** If simplification leads to `Pk  ... Pk ...`, inference fails.
    -   Successful inference: type arg determined for each bound type param, no cycles.

-   **GoScript & Divergences (Continued):**
    -   **Two-Phase Inference & Untyped Constants:**
        -   TS's inference is generally one-pass and more holistic. It doesn't have a distinct second phase specifically for "untyped constants" because TS literals (like `10`, `"str"`) have types (`number`, `string`) from the start.
        -   **Divergence:** Go's ability to delay typing for constants and then use a default type (e.g., `int` for `10` if no other context) is a key difference.
        -   GoScript, if relying on TS generics, would see TS infer `number` for `10`. If `int` (or a specific bit-size integer) is required by Go semantics, GoScript might need to:
            1.  Pre-analyze expressions to determine the Go-intended type for constants.
            2.  Emit type hints or explicit type conversions in the TS code if TS's default inference (e.g. `number` for all numeric literals) isn't specific enough.
            -   Example: `var i int = untypedConst;` -> GoScript might need to ensure `untypedConst` becomes `number` but is assignable to a Go `int` representation.
    -   **Simplification & Cyclic References:**
        -   TS's type system can handle complex recursive types and its inference can resolve many such cases.
        -   However, overly complex or truly ambiguous cyclic dependencies in type parameter definitions can also lead to errors in TS (e.g., "Type instantiation is excessively deep and possibly infinite").
        -   The behavior should be largely similar, but error messages or specific edge cases might differ.
    -   **GoScript Strategy:** For untyped constants, GoScript will likely need to determine the Go default type (e.g. `int`, `float64`, `rune`, `string`, `bool`) based on the constant's form and context, and then use the corresponding TS type (`number`, `string`, `boolean`). This might involve an earlier analysis pass before TS generation or specific handling during the AST traversal.

### Type unification

-   **Go Specification ([Go 1.18+]):**
    -   Recursively compares LHS/RHS of a type equation.
    -   Maintains map of bound type params to inferred type args (`P  A`).
    -   Example: `[10]struct{elem P; list []P} <sub>A</sub> [10]struct{elem string; list []string}`
        -   Unifies top-level (arrays), then elements (structs), then fields.
        -   `P` vs `string` -> adds `P  string` to map.
        -   `[]P` vs `[]string` -> `P` vs `string`. `P` is now known as `string` from map. `string` vs `string` unifies.
    -   Succeeds if no step fails and map fully populated.
    -   **Exact vs. Loose Unification:**
        -   Depends on context: type identity, assignability, structural equality.
        -   `X <sub>A</sub> Y` (assignment): top-level loose, elements exact.
    -   **`P <sub>C</sub> C` (Constraint Unification):**
        -   If `C`'s types all have same underlying `U`, and `P` is known `A`: `U` and `A` unify loosely.
        -   Similar for channel types in `C`.
        -   If `P` unknown & `C` has one non-tilde type term `T`: `P  T`.
        -   If `P` known `A`, and `C` doesn't have a common `U`: `A` must have `C`'s methods, method types unify exactly.
    -   Solving constraint equations may infer more args, enabling more equations to be solved. Process repeats.

-   **GoScript & Divergences:**
    -   **TS Unification:** TypeScript's type system performs unification implicitly during type checking and inference. It handles structural typing, nominal typing (for classes, enums to some extent), and type parameter constraints (`extends`).
    -   **Exact vs. Loose:**
        -   TS generally uses structural compatibility. "Exact" identity is less common than in Go (e.g. for named types).
        -   Assignability in TS (`A = B`) checks if `B` is assignable to `A` (structurally, considering variance).
    -   **Constraint Unification (`P extends C`):**
        -   TS checks if an inferred or provided type for `P` satisfies constraint `C`.
        -   If `C` is `SomeInterface`, TS checks for method presence and signature compatibility.
        -   If `C` is a union type, the type for `P` must be assignable to one of the union members.
        -   If `C` is `string | number`, `P` could be `string` or `number`.
        -   Go's "underlying type `U`" concept for constraints doesn't have a direct parallel in TS in the same way. TS focuses on the shape or specific types in a constraint.
    -   **Inferring `P  T` from Constraint:**
        -   Go: If `P` unknown, `constraint C {type T}` -> `P` becomes `T`.
        -   TS: If `P extends T`, and `P` is inferred from an argument of type `T`, then `P` becomes `T`. If `P extends string | number` and an argument is `string`, `P` becomes `string`.
        -   This behavior is somewhat analogous.
    -   **Iterative Process:** TS type inference is also iterative, resolving types and constraints until a stable state or an error.
    -   **Divergence:** The precise rules for Go's "loose" unification based on underlying types and the specific steps for constraint unification (especially involving tilde `~` types) are unique to Go. TS has its own sophisticated rules. While often leading to similar outcomes for common generic patterns, edge cases related to Go's specific definition of type identity and underlying types might be handled differently. GoScript would rely on TS's mechanisms, which means Go programs relying on very subtle aspects of Go's unification might behave differently or require more explicit typing when transpiled.






